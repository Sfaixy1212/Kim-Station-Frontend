import dotenv from 'dotenv';
import express from 'express';
import { DateTime } from 'luxon';
import sql from 'mssql';
import { createRequire } from 'module';
import axios from 'axios';
import https from 'https';
import jwt from 'jsonwebtoken';

// Inizializza dotenv
dotenv.config();
console.log('Stripe key:', process.env.STRIPE_SECRET_KEY);

// Configura axios per non verificare i certificati SSL
axios.defaults.httpsAgent = new https.Agent({  
  rejectUnauthorized: false
});

// Crea require per i moduli CommonJS
const require = createRequire(import.meta.url);
const aspnetIdentityPw = require('aspnet-identity-pw');
console.log('aspnetIdentityPw export:', aspnetIdentityPw);
console.log('aspnetIdentityPw.validatePassword:', typeof aspnetIdentityPw.validatePassword);

// Stripe
import Stripe from 'stripe';
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);

// Crea l'applicazione Express
const app = express();

// Endpoint pubblico per ottenere la chiave pubblica Stripe
app.get('/api/stripe/public-key', (req, res) => {
  res.json({ publicKey: process.env.STRIPE_PUBLIC_KEY || '' });
});

// --- ATTENZIONE: il webhook Stripe DEVE essere la primissima route! ---
// Nessun middleware (nemmeno connessione DB o body parser) deve precedere questa route.
app.post('/webhook/stripe', express.raw({type: 'application/json'}), async (req, res) => {
  console.log('[STRIPE WEBHOOK] Ricevuta richiesta:', {
    headers: req.headers,
    rawBody: req.body && req.body.length ? req.body.toString('utf8') : '[vuoto]'
  });
  const stripeWebhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
  const sig = req.headers['stripe-signature'];
  let event;
  try {
    event = stripe.webhooks.constructEvent(req.body, sig, stripeWebhookSecret);
    console.log('[STRIPE WEBHOOK] Evento verificato:', event.type);
    try {
      if (event.type === 'payment_intent.succeeded') {
        const pi = event.data.object;
        const userId = pi.metadata.userId;
        const amount = pi.amount / 100;
        const payload = JSON.stringify(pi);
        const orderType = pi.metadata.orderType || '';
        let carrello = [];
        let emailCliente = pi.metadata.emailCliente || '';
        let speseSpedizione = 0;
        let totaleOrdine = amount;
        let noteOrdine = '';
        let idStatoOrdineProdotto = 2; // Stato "Pagato" (modifica se necessario)

        // Prova a estrarre il carrello dal metadata o dal campo Payload
        if (pi.metadata && pi.metadata.carrello) {
          try { carrello = JSON.parse(pi.metadata.carrello); } catch(e) { carrello = []; }
        } else if (pi.metadata && pi.metadata.cart) {
          try { carrello = JSON.parse(pi.metadata.cart); } catch(e) { carrello = []; }
        } else if (pi.cart) {
          try { carrello = JSON.parse(pi.cart); } catch(e) { carrello = []; }
        }
        if (pi.metadata && pi.metadata.speseSpedizione) {
          speseSpedizione = Number(pi.metadata.speseSpedizione) || 0;
        }
        if (pi.metadata && pi.metadata.totaleOrdine) {
          totaleOrdine = Number(pi.metadata.totaleOrdine) || totaleOrdine;
        }
        if (pi.metadata && pi.metadata.noteOrdine) {
          noteOrdine = pi.metadata.noteOrdine;
        }
        
        try {
          await connectToDatabase();
          // Inserisci ordine in tbOrdiniProdotti
          const ordineResult = await new sql.Request()
            .input('idDealer', sql.Int, userId)
            .input('DataOra', sql.DateTime, DateTime.now().setZone('Europe/Rome').toFormat('yyyy-MM-dd HH:mm:ss'))
            .input('OrdineDA', sql.NVarChar, emailCliente)
            .input('SpeseSpedizione', sql.Int, speseSpedizione)
            .input('TotaleOrdine', sql.Int, totaleOrdine)
            .input('Payload', sql.NVarChar(sql.MAX), payload)
            .input('idStatoOrdineProdotto', sql.Int, idStatoOrdineProdotto)
            .input('NoteOrdine', sql.NVarChar, noteOrdine)
            .query(`
              INSERT INTO dbo.tbOrdiniProdotti
                (idDealer, DataOra, OrdineDA, SpeseSpedizione, TotaleOrdine, Payload, idStatoOrdineProdotto, NoteOrdine, Note4Dealer, NoteInterne, OrdineDaAgente, DataStato)
              OUTPUT INSERTED.IDOrdineProdotto
              VALUES
                (@idDealer, @DataOra, @OrdineDA, @SpeseSpedizione, @TotaleOrdine, @Payload, @idStatoOrdineProdotto, @NoteOrdine, '', '', 0, @DataOra)
            `);
          const idOrdineProdotto = ordineResult.recordset[0].IDOrdineProdotto;
          // Inserisci dettagli prodotti in tbDettagliOrdiniProdotti
          console.log('[DEBUG] Carrello al momento del dettaglio:', carrello);
          if (Array.isArray(carrello) && carrello.length > 0) {
            for (const prodotto of carrello) {
              const idOfferta = prodotto.id || prodotto.idOfferta || null;
              const quantita = prodotto.quantita || 1;
              let costoUnitario = prodotto.Crediti || prodotto.prezzo || 0;
              let simType = prodotto.SIMTYPE || null;
              let simCount = prodotto.SIMCOUNT || 0;
              // Recupera dati da tbOfferte se mancanti o nulli
              if (!costoUnitario || !simType || !simCount) {
                const offertaRes = await sql.query`SELECT Crediti, SIMTYPE, SIMCOUNT FROM dbo.tbOfferte WHERE IDOfferta = ${idOfferta}`;
                const offerta = offertaRes.recordset[0];
                if (offerta) {
                  if (!costoUnitario) costoUnitario = offerta.Crediti || 0;
                  if (!simType) simType = offerta.SIMTYPE || null;
                  if (!simCount) simCount = offerta.SIMCOUNT || 0;
                }
              }
              console.log('[DEBUG] Inserisco dettaglio:', { idOrdineProdotto, idOfferta, quantita, costoUnitario, simType, simCount });
              try {
                await new sql.Request()
                  .input('idOrdineProdotto', sql.Int, idOrdineProdotto)
                  .input('idOfferta', sql.Int, idOfferta)
                  .input('Quantita', sql.Int, quantita)
                  .input('CostoUnitario', sql.Int, costoUnitario)
                  .input('SIMTYPE', sql.NVarChar, simType)
                  .input('SIMCOUNT', sql.Int, simCount)
                  .query(`
                    INSERT INTO dbo.tbDettagliOrdiniProdotti
                      (idOrdineProdotto, idOfferta, Quantita, CostoUnitario, SIMTYPE, SIMCOUNT)
                    VALUES
                      (@idOrdineProdotto, @idOfferta, @Quantita, @CostoUnitario, @SIMTYPE, @SIMCOUNT)
                  `);
                console.log('[DB] Dettaglio prodotto inserito in tbDettagliOrdiniProdotti:', prodotto);
              } catch (err) {
                console.error('[ERRORE DETTAGLIO ORDINE]', err);
              }
            }
          } else {
            console.warn('[WARN] Carrello vuoto o non valido, nessun dettaglio inserito.');
          }
          console.log(`[STRIPE WEBHOOK] Ordine inserito: IDOrdineProdotto=${idOrdineProdotto}, Dealer=${userId}, Totale=${totaleOrdine}`);
        } catch (dbErr) {
          console.error('[STRIPE WEBHOOK] Errore inserimento ordine:', dbErr);
        }
      }
      console.log('[STRIPE WEBHOOK] Logica business eseguita');
    } catch (logicErr) {
      console.error('[STRIPE WEBHOOK] Errore logica business:', logicErr);
      // Non rilanciare, rispondi comunque OK
    }
    res.json({ received: true });
    console.log('[STRIPE WEBHOOK] Risposta inviata 200 OK');
  } catch (err) {
    console.error('Errore verifica webhook Stripe:', err);
    res.status(400).send(`Webhook Error: ${err.message}`);
    console.log('[STRIPE WEBHOOK] Risposta inviata 400 Bad Request');
  }
});

// Middleware per il parsing del body JSON
app.use(express.json());

// Funzione per connettersi al database
let sqlErrorListenerAdded = false;

// === API per ordini con BONIFICO ===
app.post('/api/ordine-bonifico', express.json(), async (req, res) => {
  try {
    const { carrello, emailCliente, speseSpedizione, noteOrdine, totaleOrdine, userId } = req.body;
    if (!Array.isArray(carrello) || carrello.length === 0) {
      return res.status(400).json({ error: 'Carrello vuoto' });
    }
    await connectToDatabase();
    const payload = JSON.stringify(carrello);
    const sqlReq = new sql.Request();
    sqlReq.input('idDealer', sql.Int, userId);
    sqlReq.input('DataOra', sql.DateTime, DateTime.now().setZone('Europe/Rome').toFormat('yyyy-MM-dd HH:mm:ss'));
    sqlReq.input('OrdineDA', sql.NVarChar, emailCliente);
    sqlReq.input('SpeseSpedizione', sql.Int, speseSpedizione || 0);
    sqlReq.input('TotaleOrdine', sql.Int, totaleOrdine);
    sqlReq.input('Payload', sql.NVarChar(sql.MAX), payload);
    sqlReq.input('idStatoOrdineProdotto', sql.Int, 1); // Stato 1 = In attesa bonifico
    sqlReq.input('NoteOrdine', sql.NVarChar, noteOrdine || '');
    const ordineResult = await sqlReq.query(`
      INSERT INTO dbo.tbOrdiniProdotti
        (idDealer, DataOra, OrdineDA, SpeseSpedizione, TotaleOrdine, Payload, idStatoOrdineProdotto, NoteOrdine, Tracking, NoteInterno, idUtenteUltimaModifica, DataUltimaModifica)
      OUTPUT INSERTED.IDOrdineProdotto
      VALUES
        (@idDealer, @DataOra, @OrdineDA, @SpeseSpedizione, @TotaleOrdine, @Payload, @idStatoOrdineProdotto, @NoteOrdine, '', '', 0, @DataOra)
    `);
    const idOrdineProdotto = ordineResult.recordset[0].IDOrdineProdotto;
    // Inserisci dettagli prodotti
    for (const prodotto of carrello) {
      const idOfferta = prodotto.id || prodotto.idOfferta || null;
      const quantita = prodotto.quantita || 1;
      const costoUnitario = prodotto.Crediti || prodotto.prezzo || 0;
      const simType = prodotto.SIMTYPE || null;
      const simCount = prodotto.SIMCOUNT || 0;
      await new sql.Request()
        .input('idOrdineProdotto', sql.Int, idOrdineProdotto)
        .input('idOfferta', sql.Int, idOfferta)
        .input('Quantita', sql.Int, quantita)
        .input('CostoUnitario', sql.Int, costoUnitario)
        .input('SIMTYPE', sql.NVarChar, simType)
        .input('SIMCOUNT', sql.Int, simCount)
        .query(`
          INSERT INTO dbo.tbDettagliOrdiniProdotti
            (idOrdineProdotto, idOfferta, Quantita, CostoUnitario, SIMTYPE, SIMCOUNT)
          VALUES
            (@idOrdineProdotto, @idOfferta, @Quantita, @CostoUnitario, @SIMTYPE, @SIMCOUNT)
        `);
    }
    res.json({ idOrdineProdotto });
  } catch (err) {
    console.error('[BONIFICO] Errore inserimento ordine:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});

async function connectToDatabase() {
  try {
    if (!sql.connected) {
      console.log('Tentativo di connessione al database...');
      await sql.connect(dbConfig);
      console.log('Connessione al database stabilita con successo');
      // Gestione errori di connessione: aggiungi listener solo una volta
      if (!sqlErrorListenerAdded) {
        sql.on('error', err => {
          console.error('Errore di connessione al database:', err);
          setTimeout(connectToDatabase, 5000);
        });
        sqlErrorListenerAdded = true;
      }
    }
    return true;
  } catch (err) {
    console.error('Errore durante la connessione al database:', err);
    // Ritenta la connessione dopo 5 secondi
    setTimeout(connectToDatabase, 5000);
    return false;
  }
}


// Middleware per gestire la connessione al database
app.use(async (req, res, next) => {
  try {
    const isConnected = await connectToDatabase();
    if (!isConnected) {
      return res.status(503).json({ 
        error: 'Servizio non disponibile',
        message: 'Impossibile connettersi al database. Riprova più tardi.'
      });
    }
    next();
  } catch (err) {
    console.error('Errore nel middleware database:', err);
    res.status(500).json({ 
      error: 'Errore interno del server',
      details: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
});

// Middleware per verificare e rinnovare il token JWT
app.use(async (req, res, next) => {
  // Salta il controllo del token per le rotte pubbliche
  const publicRoutes = ['/api/login', '/health', '/api/test-password'];
  if (publicRoutes.some(route => req.path.startsWith(route))) {
    return next();
  }

  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ 
      error: 'Token mancante',
      code: 'MISSING_TOKEN'
    });
  }

  try {
    // Verifica il token
    const decoded = jwt.verify(token, 'TUO_JWT_SECRET');
    
    // Aggiungi i dati dell'utente alla richiesta
    req.user = {
      id: decoded.userId,
      email: decoded.email,
      dealerId: decoded.dealerId,
      phoneNumber: decoded.phoneNumber
    };

    // Rinnova il token se manca meno di 1 ora alla scadenza
    const now = Math.floor(Date.now() / 1000);
    if (decoded.exp - now < 3600) {
      const newToken = jwt.sign(
        {
          userId: decoded.userId,
          email: decoded.email,
          dealerId: decoded.dealerId,
          phoneNumber: decoded.phoneNumber
        },
        'TUO_JWT_SECRET',
        { expiresIn: '2h' }
      );
      res.set('X-Renewed-Token', newToken);
    }

    next();
  } catch (err) {
    if (err.name === 'TokenExpiredError') {
      console.log('Token JWT scaduto per la richiesta:', req.path);
      
      // Se è una richiesta API, restituisci un errore JSON
      if (req.path.startsWith('/api/')) {
        return res.status(401).json({
          error: 'Sessione scaduta',
          code: 'TOKEN_EXPIRED',
          message: 'La tua sessione è scaduta. Per favore, effettua nuovamente il login.'
        });
      }
      
      // Altrimenti reindirizza alla pagina di login
      return res.redirect('/login?session=expired');
    }
    
    if (err.name === 'JsonWebTokenError') {
      return res.status(401).json({
        error: 'Token non valido',
        code: 'INVALID_TOKEN',
        message: 'Il token fornito non è valido.'
      });
    }

    console.error('Errore durante la verifica del token:', err);
    res.status(500).json({
      error: 'Errore durante l\'autenticazione',
      code: 'AUTH_ERROR',
      details: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
});

// Configurazione di base per la connessione al database
const dbConfig = {
  user: 'sa',
  password: '1RUDfS;1LS!u%CvWm',
  server: '54.155.32.254',
  port: 1433,
  database: 'KIM_STAGING',
  options: {
    encrypt: false,
    trustServerCertificate: true,
    enableArithAbort: true,
    connectTimeout: 15000,
    requestTimeout: 15000,
    validateBulkLoadParameters: false,
    useUTC: false,
    abortTransactionOnError: false,
    enableAnsiNullDefault: true,
    appName: 'kim-backend',
    cryptoCredentialsDetails: {
      minVersion: 'TLSv1.2'
    }
  }
};

// Avvia il server Express sempre, senza attendere la connessione al database
const PORT = process.env.PORT || 3002;
app.listen(PORT, () => {
  console.log(`Server Express in esecuzione su http://localhost:${PORT}`);
});


// Endpoint pubblico per ottenere la chiave pubblica Stripe (deve essere prima di qualsiasi middleware di autenticazione!)
app.get('/api/stripe/public-key', (req, res) => {
  res.json({ publicKey: process.env.STRIPE_PUBLIC_KEY || '' });
});

// Endpoint Stripe PaymentIntent SOLO per ricarica plafond (importi fissi)
app.post('/api/stripe/create-payment-intent', express.json(), async (req, res) => {
  try {
    const { amount, userId, metodo, carrello, emailCliente } = req.body;
    const validAmounts = [50, 100, 250, 500];
    if (!validAmounts.includes(Number(amount))) {
      return res.status(400).json({ error: 'Importo non valido' });
    }
    if (!userId) {
      return res.status(400).json({ error: 'userId mancante' });
    }
    if (metodo === 'bonifico') {
      // Bonifico SEPA Stripe (Customer Balance)
      await sql.connect(dbConfig);
      let stripeCustomerId;
      let selectReq = new sql.Request();
      selectReq.input('IDDealer', sql.Int, parseInt(userId, 10));
      const dealerRes = await selectReq.query('SELECT TOP 1 StripeCustomerId FROM dbo.tbDealers WHERE IDDealer = @IDDealer');
      if (dealerRes.recordset.length && dealerRes.recordset[0].StripeCustomerId) {
        stripeCustomerId = dealerRes.recordset[0].StripeCustomerId;
      } else {
        const customer = await stripe.customers.create({ metadata: { userId: String(userId) } });
        stripeCustomerId = customer.id;
        let updateReq = new sql.Request();
        updateReq.input('StripeCustomerId', sql.NVarChar, stripeCustomerId);
        updateReq.input('IDDealer', sql.Int, parseInt(userId, 10));
        await updateReq.query('UPDATE dbo.tbDealers SET StripeCustomerId = @StripeCustomerId WHERE IDDealer = @IDDealer');
      }
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Number(amount) * 100,
        currency: 'eur',
        customer: stripeCustomerId,
        payment_method_types: ['customer_balance'],
        payment_method_options: {
          customer_balance: {
            funding_type: 'bank_transfer',
            bank_transfer: {
              type: 'eu_bank_transfer',
              eu_bank_transfer: { country: 'DE' }
            }
          }
        },
        metadata: { userId: String(userId) }
      });
      const instructionsObj = await stripe.customers.createFundingInstructions(stripeCustomerId, {
        bank_transfer: {
          type: 'eu_bank_transfer',
          eu_bank_transfer: { country: 'DE' }
        },
        currency: 'eur',
        funding_type: 'bank_transfer'
      });
      const instructions = instructionsObj?.bank_transfer || null;
      res.json({ client_secret: paymentIntent.client_secret, bank_instructions: instructions });
    } else {
      // Carta di credito
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Number(amount) * 100, // euro -> centesimi
        currency: 'eur',
        payment_method_types: ['card'],
        metadata: { userId: String(userId) }
      });
      res.json({ client_secret: paymentIntent.client_secret });
    }
  } catch (err) {
    console.error('Errore creazione PaymentIntent:', err);
    res.status(500).json({ error: 'Errore server Stripe' });
  }
});

// Endpoint Stripe PaymentIntent per pagamenti prodotti (importo libero)
app.post('/api/stripe/create-product-payment-intent', express.json(), async (req, res) => {
  try {
    const { amount, userId, carrello, emailCliente, speseSpedizione, noteOrdine, metadata = {} } = req.body;
    if (!amount || isNaN(Number(amount))) {
      return res.status(400).json({ error: 'Importo non valido' });
    }
    if (!userId) {
      return res.status(400).json({ error: 'userId mancante' });
    }
    // You can add further validation for carrello, emailCliente, etc. if needed
    // Prepara un carrello "safe" solo con id e quantità
    const safeCarrello = carrello && Array.isArray(carrello)
      ? JSON.stringify(carrello.map(({ id, quantita }) => ({ id, quantita })))
      : '';
    // Costruisci un metadata solo con stringhe e campi semplici
    const safeMetadata = {
      userId: String(userId),
      emailCliente: String(emailCliente || ''),
      carrello: safeCarrello,
      speseSpedizione: typeof speseSpedizione !== 'undefined' ? String(speseSpedizione) : '0',
      noteOrdine: String(noteOrdine || ''),
      ...Object.fromEntries(
        Object.entries(metadata || {}).filter(([k, v]) => typeof v === 'string' || typeof v === 'number')
      )
    };
    safeMetadata.carrello = safeCarrello;

    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(Number(amount) * 100),
      currency: 'eur',
      payment_method_types: ['card'],
      metadata: safeMetadata
    });
    res.json({ client_secret: paymentIntent.client_secret });
  } catch (err) {
    console.error('Errore creazione PaymentIntent prodotto:', err);
    res.status(500).json({ error: 'Errore server Stripe' });
  }
});

// Endpoint Stripe PaymentIntent per pagamenti carrello ecommerce (importo libero)
app.post('/api/stripe/cart-payment-intent', express.json(), async (req, res) => {
  try {
    const { amount, userId, metodo, orderToken } = req.body;
    if (!amount || isNaN(Number(amount))) {
      return res.status(400).json({ error: 'Importo non valido' });
    }
    if (!userId) {
      return res.status(400).json({ error: 'userId mancante' });
    }
    if (metodo === 'bonifico') {
      await sql.connect(dbConfig);
      let stripeCustomerId;
      let selectReq = new sql.Request();
      selectReq.input('IDDealer', sql.Int, parseInt(userId, 10));
      const dealerRes = await selectReq.query('SELECT TOP 1 StripeCustomerId FROM dbo.tbDealers WHERE IDDealer = @IDDealer');
      if (dealerRes.recordset.length && dealerRes.recordset[0].StripeCustomerId) {
        stripeCustomerId = dealerRes.recordset[0].StripeCustomerId;
      } else {
        const customer = await stripe.customers.create({ metadata: { userId: String(userId) } });
        stripeCustomerId = customer.id;
        let updateReq = new sql.Request();
        updateReq.input('StripeCustomerId', sql.NVarChar, stripeCustomerId);
        updateReq.input('IDDealer', sql.Int, parseInt(userId, 10));
        await updateReq.query('UPDATE dbo.tbDealers SET StripeCustomerId = @StripeCustomerId WHERE IDDealer = @IDDealer');
      }
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(Number(amount) * 100),
        currency: 'eur',
        customer: stripeCustomerId,
        payment_method_types: ['customer_balance'],
        payment_method_options: {
          customer_balance: {
            funding_type: 'bank_transfer',
            bank_transfer: {
              type: 'eu_bank_transfer',
              eu_bank_transfer: { country: 'DE' }
            }
          }
        },
        metadata: {
          userId: String(userId),
          orderToken
        }
      });
      const instructionsObj = await stripe.customers.createFundingInstructions(stripeCustomerId, {
        bank_transfer: {
          type: 'eu_bank_transfer',
          eu_bank_transfer: { country: 'DE' }
        },
        currency: 'eur',
        funding_type: 'bank_transfer'
      });
      const instructions = instructionsObj?.bank_transfer || null;
      res.json({ client_secret: paymentIntent.client_secret, bank_instructions: instructions });
    } else {
      // Carta di credito
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(Number(amount) * 100),
        currency: 'eur',
        payment_method_types: ['card'],
        metadata: {
          userId: String(userId),
          orderToken
        }
      });
      res.json({ client_secret: paymentIntent.client_secret });
    }
  } catch (err) {
    console.error('Errore creazione PaymentIntent carrello:', err);
    res.status(500).json({ error: 'Errore server Stripe' });
  }
});


// Endpoint per salvataggio pre-ordine temporaneo
app.post('/api/order/pre-save', express.json(), async (req, res) => {
  try {
    const { orderToken, userId, emailCliente, carrello } = req.body;
    if (!orderToken || !userId || !carrello) {
      return res.status(400).json({ error: 'orderToken, userId, carrello sono obbligatori' });
    }
    await sql.connect(dbConfig);
    await new sql.Request()
      .input('OrderToken', sql.NVarChar(64), orderToken)
      .input('UserId', sql.Int, userId)
      .input('EmailCliente', sql.NVarChar(255), emailCliente || '')
      .input('Carrello', sql.NVarChar(sql.MAX), carrello)
      .query(`INSERT INTO dbo.tbOrdiniTemp (OrderToken, UserId, EmailCliente, Carrello) VALUES (@OrderToken, @UserId, @EmailCliente, @Carrello)`);
    res.json({ ok: true });
  } catch (err) {
    console.error('[PRE-SAVE ERROR]', err);
    res.status(500).json({ error: 'Errore nel salvataggio pre-ordine' });
  }
});

// Endpoint richiesta bonifico (solo log)
app.post('/api/bonifico-request', express.json(), (req, res) => {
  const { amount, userId } = req.body;
  console.log('Richiesta bonifico:', { amount, userId });
  res.json({ ok: true });
});

// Endpoint per ricarica plafond
app.post('/api/ricarica-plafond', express.json(), async (req, res) => {
  try {
    const { amount, payment_method_types, userId } = req.body;
    // amount in euro, converti in centesimi
    const amountCents = Math.round(Number(amount) * 100);
    if (![5000, 10000, 25000, 50000].includes(amountCents)) {
      return res.status(400).json({ error: 'Importo non valido' });
    }
    if (!Array.isArray(payment_method_types) || !payment_method_types.length) {
      return res.status(400).json({ error: 'Metodo di pagamento mancante' });
    }
    if (!userId) {
      return res.status(400).json({ error: 'userId mancante' });
    }
    // Crea PaymentIntent Stripe
    const paymentIntent = await stripe.paymentIntents.create({
      amount: amountCents,
      currency: 'eur',
      payment_method_types, // ['card'] o ['customer_bank_transfer']
      metadata: { userId }
    });
    res.json({ clientSecret: paymentIntent.client_secret });
  } catch (err) {
    console.error('Errore in /api/ricarica-plafond:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});

app.post('/webhook/stripe', express.raw({type: 'application/json'}), async (req, res) => {
  // LOG: webhook chiamato
  console.log('[STRIPE WEBHOOK] Ricevuta richiesta:', {
    headers: req.headers,
    rawBody: req.body && req.body.length ? req.body.toString('utf8') : '[vuoto]'
  });
  const stripeWebhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
  const sig = req.headers['stripe-signature'];
  let event;
  try {
    event = stripe.webhooks.constructEvent(req.body, sig, stripeWebhookSecret);
  } catch (err) {
    console.error('Errore verifica webhook Stripe:', err);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  if (event.type === 'payment_intent.succeeded') {
    const pi = event.data.object;
    const userId = pi.metadata.userId;
    const amount = pi.amount / 100;
    const payload = JSON.stringify(pi);
    let carrello = [];
    let emailCliente = '';
    let speseSpedizione = 0;
    let totaleOrdine = amount;
    let noteOrdine = '';
    let idStatoOrdineProdotto = 2; // Stato "Pagato"

    // Robust: fetch full cart and info from tbOrdiniTemp using orderToken
    if (pi.metadata && pi.metadata.orderToken) {
      try {
        await sql.connect(dbConfig);
        const tempRes = await new sql.Request()
          .input('OrderToken', sql.NVarChar(64), pi.metadata.orderToken)
          .query('SELECT TOP 1 * FROM dbo.tbOrdiniTemp WHERE OrderToken = @OrderToken');
        if (tempRes.recordset.length) {
          const temp = tempRes.recordset[0];
          carrello = JSON.parse(temp.Carrello);
          emailCliente = temp.EmailCliente || '';
          // You may add more fields here if needed
        } else {
          console.warn('[STRIPE WEBHOOK] Nessun pre-ordine trovato per orderToken:', pi.metadata.orderToken);
        }
      } catch (e) {
        console.error('[STRIPE WEBHOOK] Errore recupero pre-ordine:', e);
      }
    } else {
      console.warn('[STRIPE WEBHOOK] orderToken non presente in metadata!');
    }
    try {
      await sql.connect(dbConfig);
      // Inserisci ordine in tbOrdiniProdotti
      const ordineResult = await new sql.Request()
        .input('idDealer', sql.Int, userId)
        .input('DataOra', sql.DateTime, DateTime.now().setZone('Europe/Rome').toFormat('yyyy-MM-dd HH:mm:ss'))
        .input('OrdineDA', sql.NVarChar, emailCliente)
        .input('SpeseSpedizione', sql.Int, speseSpedizione)
        .input('TotaleOrdine', sql.Int, totaleOrdine)
        .input('Payload', sql.NVarChar(sql.MAX), payload)
        .input('idStatoOrdineProdotto', sql.Int, idStatoOrdineProdotto)
        .input('NoteOrdine', sql.NVarChar, noteOrdine)
        .query(`
          INSERT INTO dbo.tbOrdiniProdotti
            (idDealer, DataOra, OrdineDA, SpeseSpedizione, TotaleOrdine, Payload, idStatoOrdineProdotto, NoteOrdine, Note4Dealer, NoteInterne, OrdineDaAgente, DataStato)
          OUTPUT INSERTED.IDOrdineProdotto
          VALUES
            (@idDealer, @DataOra, @OrdineDA, @SpeseSpedizione, @TotaleOrdine, @Payload, @idStatoOrdineProdotto, @NoteOrdine, '', '', 0, @DataOra)
        `);
      console.log('[DB] Ordine inserito in tbOrdiniProdotti:', ordineResult);
      const idOrdineProdotto = ordineResult.recordset[0].IDOrdineProdotto;
      // Inserisci dettagli prodotti in tbDettagliOrdiniProdotti
      console.log('[DEBUG] Carrello al momento del dettaglio:', carrello);
if (Array.isArray(carrello) && carrello.length > 0) {
  for (const prodotto of carrello) {
    const idOfferta = prodotto.id || prodotto.idOfferta || null;
    const quantita = prodotto.quantita || 1;
    const costoUnitario = prodotto.Crediti || prodotto.prezzo || 0;
    const simType = prodotto.SIMTYPE || null;
    const simCount = prodotto.SIMCOUNT || 0;
    console.log('[DEBUG] Inserisco dettaglio:', { idOrdineProdotto, idOfferta, quantita, costoUnitario, simType, simCount });
    try {
      await new sql.Request()
        .input('idOrdineProdotto', sql.Int, idOrdineProdotto)
        .input('idOfferta', sql.Int, idOfferta)
        .input('Quantita', sql.Int, quantita)
        .input('CostoUnitario', sql.Int, costoUnitario)
        .input('SIMTYPE', sql.NVarChar, simType)
        .input('SIMCOUNT', sql.Int, simCount)
        .query(`
          INSERT INTO dbo.tbDettagliOrdiniProdotti
            (idOrdineProdotto, idOfferta, Quantita, CostoUnitario, SIMTYPE, SIMCOUNT)
          VALUES
            (@idOrdineProdotto, @idOfferta, @Quantita, @CostoUnitario, @SIMTYPE, @SIMCOUNT)
        `);
      console.log('[DB] Dettaglio prodotto inserito in tbDettagliOrdiniProdotti:', prodotto);
    } catch (err) {
      console.error('[ERRORE DETTAGLIO ORDINE]', err);
    }
  }
}
      console.log(`Ordine inserito: IDOrdineProdotto=${idOrdineProdotto}, Dealer=${userId}, Totale=${totaleOrdine}`);
    } catch (err) {
      console.error('Errore inserimento ordine prodotti:', err);
    }
  }

  res.json({received: true});
});

// Endpoint di test semplice
app.get('/api/test', (req, res) => {
  res.json({ status: 'ok', message: 'Il server è in esecuzione' });
});

// Endpoint per la dashboard: ultime 5 attivazioni
app.get('/api/ultime-attivazioni', async (req, res) => {
  try {
    // Estrai il token JWT dall'header Authorization
    const authHeader = req.headers['authorization'];
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token mancante' });
    }
    const token = authHeader.split(' ')[1];
    let decoded;
    try {
      decoded = jwt.verify(token, 'TUO_JWT_SECRET');
      if (!decoded.userId) {
        return res.status(401).json({ error: 'Token non valido: userId mancante' });
      }
    } catch (err) {
      return res.status(401).json({ error: 'Token non valido o scaduto' });
    }
    // Converti l'ID da stringa a numero
    const dealerId = parseInt(decoded.userId, 10);
    if (isNaN(dealerId)) {
      return res.status(401).json({ error: 'ID dealer non valido' });
    }
    await sql.connect(dbConfig);
    const request = new sql.Request();
    request.input('idDealer', sql.Int, dealerId);
    // Logica filtro operatore per la dashboard
    let query;
    const operatore = req.query.operatore;
    if (operatore === 'SKY') {
      query = `
        SELECT TOP 5
          CONVERT(VARCHAR(10), o.DataOra, 120) AS Data,
          offr.Titolo AS Titolo,
          offr.Tipo AS Tipo,
          offr.Segmento AS Segmento,
          so.StatoEsteso AS Stato
        FROM dbo.tbOrdini o
        LEFT JOIN dbo.tbStatiOrdini so ON o.Stato = so.IDStato
        LEFT JOIN dbo.TbOfferte offr ON o.idOfferta = offr.IDOfferta
        WHERE o.idDealer = @idDealer
          AND offr.idOperatore IN (3, 8, 12, 14)
        ORDER BY o.DataOra DESC`;
    } else if (operatore === 'ILIAD') {
      query = `
        SELECT TOP 5
          CONVERT(VARCHAR(10), o.DataOra, 120) AS Data,
          offr.Titolo AS Titolo,
          offr.Tipo AS Tipo,
          offr.Segmento AS Segmento,
          so.StatoEsteso AS Stato
        FROM dbo.tbOrdini o
        LEFT JOIN dbo.tbStatiOrdini so ON o.Stato = so.IDStato
        LEFT JOIN dbo.TbOfferte offr ON o.idOfferta = offr.IDOfferta
        WHERE o.idDealer = @idDealer
          AND offr.idOperatore IN (5)
        ORDER BY o.DataOra DESC`;
    } else if (operatore === 'KENA MOBILE') {
      query = `
        SELECT TOP 5
          CONVERT(VARCHAR(10), o.DataOra, 120) AS Data,
          offr.Titolo AS Titolo,
          offr.Tipo AS Tipo,
          offr.Segmento AS Segmento,
          so.StatoEsteso AS Stato
        FROM dbo.tbOrdini o
        LEFT JOIN dbo.tbStatiOrdini so ON o.Stato = so.IDStato
        LEFT JOIN dbo.TbOfferte offr ON o.idOfferta = offr.IDOfferta
        WHERE o.idDealer = @idDealer
          AND offr.idOperatore IN (6)
        ORDER BY o.DataOra DESC`;
    } else if (operatore === 'WEEDOO') {
      query = `
        SELECT TOP 5
          CONVERT(VARCHAR(10), o.DataOra, 120) AS Data,
          offr.Titolo AS Titolo,
          offr.Tipo AS Tipo,
          offr.Segmento AS Segmento,
          so.StatoEsteso AS Stato
        FROM dbo.tbOrdini o
        LEFT JOIN dbo.tbStatiOrdini so ON o.Stato = so.IDStato
        LEFT JOIN dbo.TbOfferte offr ON o.idOfferta = offr.IDOfferta
        WHERE o.idDealer = @idDealer
          AND offr.idOperatore IN (13)
        ORDER BY o.DataOra DESC`;
    } else if (operatore === '1MOBILE') {
      query = `
        SELECT TOP 5
          CONVERT(VARCHAR(10), o.DataOra, 120) AS Data,
          offr.Titolo AS Titolo,
          offr.Tipo AS Tipo,
          offr.Segmento AS Segmento,
          so.StatoEsteso AS Stato
        FROM dbo.tbOrdini o
        LEFT JOIN dbo.tbStatiOrdini so ON o.Stato = so.IDStato
        LEFT JOIN dbo.TbOfferte offr ON o.idOfferta = offr.IDOfferta
        WHERE o.idDealer = @idDealer
          AND offr.idOperatore IN (7)
        ORDER BY o.DataOra DESC`;
    } else if (operatore === 'FASTWEB') {
      query = `
        WITH CTE_OrdiniUnici AS (
            SELECT
                CONVERT(VARCHAR(10), i.[Data Inserimento Ordine], 105) AS Data,
                i.Valore AS Valore,
                i.[FiscalCodeOrPiva] AS CodiceFiscale,
                i.Segmento AS Segmento,
                i.[Codice Ordine] AS CodiceOrdine,
                i.[Stato dell'Ordine OM] AS StatoOrdine,
                i.Contributo,
                i.[Tipo Ordine] AS TipoOrdine,
                i.Canone,
                ROW_NUMBER() OVER (PARTITION BY i.[Codice Ordine] ORDER BY i.[Data Inserimento Ordine] DESC) AS rn
            FROM dbo.InseritoFW i
            INNER JOIN dbo.tbDealers d 
                ON i.[Codice Comsy Tecnico Attuale] = d.COMSY1
                OR i.[Codice Comsy Tecnico Attuale] = d.COMSY2
            WHERE d.idDealer = @idDealer
        )
        SELECT TOP 5
            Data,
            LEFT(Valore, 30) AS Titolo,
            TipoOrdine AS Tipo,
            Segmento,
            StatoOrdine AS Stato,
            CodiceOrdine,
            Contributo,
            TipoOrdine,
            Canone
        FROM CTE_OrdiniUnici
        WHERE rn = 1
        ORDER BY Data DESC`;
    } else if (operatore === 'FASTWEB ENERGIA') {
      query = `
        WITH CTE_ContrattiUnici AS (
            SELECT
                CONVERT(VARCHAR(10), f.[DataBatch], 105) AS Data,
                f.[Codice Contratto] AS CodiceContratto,
                f.[Codice POD] AS CodicePOD,
                f.[Tipo Cliente] AS TipoCliente,
                f.Segmento,
                f.[Stato Contratto] AS StatoContratto,
                f.[Stato Fornitura Luce] AS StatoFornitura,
                f.[Tipo Vendita] AS TipoVendita,
                f.[Tipo Passaggio] AS TipoPassaggio,
                f.[Nome Offerta Vendita] AS NomeOfferta,
                ROW_NUMBER() OVER (PARTITION BY f.[Codice Contratto] ORDER BY f.[DataBatch] DESC) AS rn
            FROM dbo.FWEnergiaimporter f
            INNER JOIN dbo.tbDealers d 
                ON f.[Codice Comsy/Order Owner (Report!DBSELLER)] = d.COMSY1
                OR f.[Codice Comsy/Order Owner (Report!DBSELLER)] = d.COMSY2
            WHERE d.idDealer = @idDealer
        )
        SELECT TOP 5
            Data,
            o.Titolo,
            CodicePOD AS Tipo,
            Segmento,
            StatoContratto AS Stato,
            StatoFornitura,
            TipoCliente,
            TipoVendita,
            TipoPassaggio,
            f.[Nome Offerta Vendita] AS NomeOfferta
        FROM CTE_ContrattiUnici
        WHERE rn = 1
        ORDER BY Data DESC`;
    } else if (operatore) {
      query = `
        SELECT TOP 5
          CONVERT(VARCHAR(10), o.DataOra, 120) AS Data,
          offr.Titolo AS Titolo,
          offr.Tipo AS Tipo,
          offr.Segmento AS Segmento,
          so.StatoEsteso AS Stato
        FROM dbo.tbOrdini o
        LEFT JOIN dbo.tbStatiOrdini so ON o.Stato = so.IDStato
        LEFT JOIN dbo.TbOfferte offr ON o.idOfferta = offr.IDOfferta
        WHERE o.idDealer = @idDealer
          AND offr.idOperatore = (SELECT TOP 1 IDOperatore FROM dbo.tbOperatori2 WHERE UPPER(Nome) = UPPER(@operatore))
        ORDER BY o.DataOra DESC`;
      request.input('operatore', sql.NVarChar, operatore);
    } else {
      query = `
        SELECT TOP 5
          CONVERT(VARCHAR(10), o.DataOra, 120) AS Data,
          offr.Titolo AS Titolo,
          offr.Tipo AS Tipo,
          offr.Segmento AS Segmento,
          so.StatoEsteso AS Stato
        FROM dbo.tbOrdini o
        LEFT JOIN dbo.tbStatiOrdini so ON o.Stato = so.IDStato
        LEFT JOIN dbo.TbOfferte offr ON o.idOfferta = offr.IDOfferta
        WHERE o.idDealer = @idDealer
        ORDER BY o.DataOra DESC`;
    }
    const result = await request.query(query);
    res.json({ attivazioni: result.recordset || [] });
  } catch (err) {
    console.error('Errore in /api/ultime-attivazioni:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});

// Endpoint di debug connessione DB
app.get('/api/debug-db', async (req, res) => {
  try {
    const sql = require('mssql');
    const pool = await sql.connect(dbConfig);
    const result = await pool.request().query('SELECT 1 as test');
    res.json({ status: 'success', result: result.recordset });
    sql.close();
  } catch (err) {
    res.status(500).json({ status: 'error', error: err, message: err.message });
  }
});

// Endpoint di verifica della connessione al database
app.get('/api/check-db', async (req, res) => {
  try {
    const sql = require('mssql');
    const pool = await sql.connect(dbConfig);
    const result = await pool.request().query('SELECT name FROM sys.databases');
    res.json({
      status: 'success',
      databases: result.recordset,
      timestamp: new Date().toISOString()
    });
    sql.close();
  } catch (error) {
    console.error('Errore nel test del database:', error);
    res.status(500).json({
      status: 'error',
      message: 'Errore durante il test del database',
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Endpoint di verifica della connessione al database specifico
app.get('/api/check-db-connection', async (req, res) => {
  try {
    const pool = await sql.connect(dbConfig);
    await pool.request().query('SELECT 1');
    res.json({ status: 'success', message: 'Connessione al database riuscita' });
    pool.close();
    sql.close();
  } catch (err) {
    res.status(500).json({ status: 'error', error: err.message });
  }
});

// Endpoint temporaneo per testare la verifica password ASP.NET Identity
app.post('/api/test-password', express.json(), (req, res) => {
  const { password, hash } = req.body;
  try {
    const result = aspnetIdentityPw.validatePassword(password, hash);
    res.json({ valid: result });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// CORS middleware per sviluppo
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  if (req.method === 'OPTIONS') {
    return res.sendStatus(200);
  }
  next();
});

app.use(express.json());

// Endpoint per restituire i templates
import * as fs from 'fs/promises';
app.get('/api/templates', async (req, res) => {
  try {
    const data = await fs.readFile('/home/ubuntu/backend/templates.json', 'utf8');
    res.json(JSON.parse(data));
  } catch (err) {
    res.status(500).json({ error: 'Impossibile leggere templates.json', details: err.message });
  }
});

// Endpoint per il controllo dello stato del server
app.get('/health', async (req, res) => {
  try {
    // Verifica la connessione al database
    await sql.query('SELECT 1');
    
    res.json({
      status: 'ok',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      database: 'connected'
    });
  } catch (error) {
    console.error('Health check failed:', error);
    res.status(500).json({
      status: 'error',
      error: 'Database connection failed',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

app.post('/api/login', express.json(), async (req, res) => {
  console.log('Richiesta di login ricevuta:', {
    headers: req.headers,
    body: req.body,
    ip: req.ip,
    method: req.method,
    url: req.originalUrl
  });
  
  const { username, email, password } = req.body;
  
  // Usa email se presente, altrimenti username
  const loginIdentifier = email || username;
  
  if (!loginIdentifier || !password) {
    console.log('Credenziali mancanti:', { 
      email: !!email, 
      username: !!username, 
      password: !!password 
    });
    return res.status(400).json({ 
      error: 'Credenziali mancanti',
      message: 'Inserisci email/username e password'
    });
  }

  try {
    await sql.connect(dbConfig);
    const request = new sql.Request();
    
    // Cerca direttamente il dealer per email nel campo RecapitoEmail
    request.input('email', sql.NVarChar, loginIdentifier);
    const query = `SELECT * FROM dbo.tbDealers WHERE RecapitoEmail = @email`;
    console.log('Esecuzione query dealer:', query, 'con email:', loginIdentifier);
    
    const result = await request.query(query);
    console.log('Risultato query dealer:', result.recordset);
    
    if (!result.recordset || result.recordset.length === 0) {
      console.log('Nessun dealer trovato per email:', loginIdentifier);
      return res.status(401).json({ 
        error: 'Credenziali non valide',
        message: 'Nessun account trovato con questa email.'
      });
    }
    
    const dealer = result.recordset[0];
    console.log('Dealer trovato:', {
      dealerId: dealer.IDDealer,
      email: dealer.RecapitoEmail,
      hasPassword: !!dealer.TmpPasswd,
      actualPasswordField: dealer.TmpPasswd || 'undefined'
    });
    
    console.log('Verifica password in corso...');
    console.log('Password fornita:', password);
    console.log('Password nel DB:', dealer.TmpPasswd);
    
    // Confronto diretto della password (senza hashing)
    const isPasswordValid = password === dealer.TmpPasswd;
    console.log('Risultato verifica password:', isPasswordValid);
    
    if (!isPasswordValid) {
      console.log('Password non valida per il dealer:', dealer.RecapitoEmail);
      return res.status(401).json({ 
        error: 'Credenziali non valide',
        message: 'La password inserita non è corretta.'
      });
    }
    
    // Se la password è corretta, genera il token
    const tokenPayload = {
      userId: dealer.IDDealer,
      email: dealer.RecapitoEmail,
      dealerId: dealer.IDDealer,
      phoneNumber: dealer.RecapitoCell || ''
    };
    
    console.log('Generazione token con payload:', tokenPayload);
    
    const token = jwt.sign(
      tokenPayload,
      'TUO_JWT_SECRET',
      { expiresIn: '2h' }
    );
    
    console.log('Token JWT generato con successo');
    
    // Formatta il numero di telefono
    let phoneNumber = 'web_user';
    if (dealer.RecapitoCell) {
      // Rimuovi tutti i caratteri non numerici e prendi le ultime 10 cifre
      const cleanNumber = dealer.RecapitoCell.replace(/\D/g, '').slice(-10);
      if (cleanNumber.length === 10) {
        phoneNumber = '39' + cleanNumber;
      }
    }
    
    res.json({ 
      token, 
      dealerName: dealer.RagioneSociale || dealer.RecapitoEmail,
      phoneNumber: phoneNumber
    });
  } catch (err) {
    console.error('Errore durante il login:', err);
    res.status(500).json({ 
      error: 'Errore server', 
      details: err.message,
      stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
    });
  }
});

app.get('/api/attivazioni', async (req, res) => {
  try {
    // Estrai il token JWT dall'header Authorization
    const authHeader = req.headers['authorization'];
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token mancante' });
    }
    const token = authHeader.split(' ')[1];
    let decoded;
    try {
      decoded = jwt.verify(token, 'TUO_JWT_SECRET');
      if (!decoded.userId) {
        return res.status(401).json({ error: 'Token non valido: userId mancante' });
      }
    } catch (err) {
      return res.status(401).json({ error: 'Token non valido o scaduto' });
    }

    // Usa dealerId dal token JWT
    const dealerId = decoded.dealerId;
    if (!dealerId) {
      return res.status(401).json({ error: 'ID dealer non valido' });
    }

    console.log('Esecuzione query attivazioni per dealer ID:', dealerId);
    
    try {
      // Trova la ragione sociale del dealer
      await sql.connect(dbConfig);
      const request = new sql.Request();
      request.input('idDealer', sql.Int, dealerId);
      const dealerQuery = `SELECT RagioneSociale FROM dbo.tbDealers WHERE IDDealer = @idDealer`;
      const dealerRes = await request.query(dealerQuery);
      
      if (!dealerRes.recordset.length) {
        return res.status(404).json({ error: 'Dealer non trovato' });
      }
      
      const ragioneSociale = dealerRes.recordset[0].RagioneSociale;
      
      // Query per ottenere le ultime 5 attivazioni
      const query = `
        SELECT TOP 5
          CONVERT(VARCHAR(10), o.DataOra, 120) AS Data,
          offr.Titolo AS Titolo,
          offr.Tipo AS Tipo,
          offr.Segmento AS Segmento,
          so.StatoEsteso AS Stato
        FROM dbo.tbOrdini o
        LEFT JOIN dbo.tbStatiOrdini so ON o.Stato = so.IDStato
        LEFT JOIN dbo.TbOfferte offr ON o.idOfferta = offr.IDOfferta
        WHERE o.idDealer = @idDealer
        ORDER BY o.DataOra DESC`;
      
      console.log('Esecuzione query attivazioni:', query);
      
      const result = await request.query(query);
      
      console.log('Risultati query attivazioni:', JSON.stringify(result.recordset, null, 2));
      
      return res.json({ 
        ragioneSociale, 
        attivazioni: result.recordset || [] 
      });
      
    } catch (err) {
      console.error('Errore durante l\'esecuzione della query attivazioni:', err);
      throw err; // Rilancia l'errore per la gestione nel blocco catch esterno
    }
  } catch (err) {
    console.error('Errore in /api/attivazioni:', err);
    // Verifica se la risposta è già stata inviata
    if (!res.headersSent) {
      return res.status(500).json({ 
        error: 'Errore del server', 
        details: err.message,
        code: err.code
      });
    } else {
      console.error('Tentativo di inviare una risposta multipla per la stessa richiesta');
    }
  }
});

app.get('/api/ordini', async (req, res) => {
  try {
    // Estrai il token JWT dall'header Authorization
    const authHeader = req.headers['authorization'];
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token mancante' });
    }
    const token = authHeader.substring(7);
    let email;
    try {
      const decoded = jwt.verify(token, 'TUO_JWT_SECRET');
      email = decoded.email;
    } catch (err) {
      return res.status(401).json({ error: 'Token non valido' });
    }
    await sql.connect(dbConfig);
    const request = new sql.Request();
    request.input('email', sql.NVarChar, email);
    // Trova idDealer e RagioneSociale dell'utente loggato
    const dealerQuery = `SELECT TOP 1 IDDealer, RagioneSociale FROM dbo.tbDealers WHERE RecapitoEmail = @email`;
    const dealerRes = await request.query(dealerQuery);
    if (!dealerRes.recordset.length) {
      return res.status(404).json({ error: 'Dealer non trovato per questa email' });
    }
    const idDealer = dealerRes.recordset[0].IDDealer;
    const ragioneSociale = dealerRes.recordset[0].RagioneSociale;
    // Query per ultimi 5 ordini del dealer
    request.input('idDealer', sql.Int, idDealer);
    const query = `
      SELECT TOP 5
        CONVERT(VARCHAR(10), op.DataOra, 120) AS Data,
        of.Titolo AS Prodotto,
        of.Tipo AS Tipo,
        op.TotaleOrdine AS Importo,
        op.SpeseSpedizione,
        op.idStatoOrdineProdotto AS Stato
      FROM dbo.tbOrdiniProdotti op
      LEFT JOIN dbo.tbOfferte of ON op.idOfferta = of.IDOfferta
      WHERE op.idDealer = @idDealer
      ORDER BY op.DataOra DESC`;

    try {
      const result = await request.query(query);
      res.json({ ragioneSociale, ordini: result.recordset });
    } catch (err) {
      console.error('ERRORE QUERY ORDINI:', err.message, err.stack);
      res.status(500).json({ error: 'Errore server nella query ordini', details: err.message });
    }
  } catch (err) {
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});


// --- API: ULTIMI ORDINI ---
// GET /api/ultimi-ordini
app.get('/api/ultimi-ordini', async (req, res) => {
  try {
    // Autenticazione JWT
    const authHeader = req.headers['authorization'];
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token mancante' });
    }
    
    const token = authHeader.split(' ')[1];
    let decoded;
    try {
      decoded = jwt.verify(token, 'TUO_JWT_SECRET');
      if (!decoded.userId) {
        return res.status(401).json({ error: 'Token non valido: userId mancante' });
      }
    } catch (err) {
      return res.status(401).json({ error: 'Token non valido o scaduto' });
    }

    // Usa dealerId dal token JWT
    const dealerId = decoded.dealerId;
    if (!dealerId) {
      return res.status(401).json({ error: 'ID dealer non valido' });
    }

    console.log('Esecuzione query ultimi ordini per dealer ID:', dealerId);
    await sql.connect(dbConfig);
    const request = new sql.Request();
    request.input('idDealer', sql.Int, dealerId);
    
    const query = `
      SELECT TOP 5
        CONVERT(VARCHAR(10), o.DataOra, 120) AS Data,
        offr.Titolo AS Prodotto,
        offr.Tipo AS Tipo,
        o.TotaleOrdine AS Importo,
        o.SpeseSpedizione,
        so.StatoEsteso AS Stato
      FROM dbo.tbOrdiniProdotti o
      LEFT JOIN dbo.tbStatiOrdiniProdotti so ON o.idStatoOrdineProdotto = so.IDStato
      LEFT JOIN dbo.tbDettagliOrdiniProdotti dop ON o.IDOrdineProdotto = dop.idOrdineProdotto
      LEFT JOIN dbo.tbOfferte offr ON dop.idOfferta = offr.IDOfferta
      WHERE o.idDealer = @idDealer
      ORDER BY o.DataOra DESC`;
      
    console.log('Esecuzione query ultimi ordini per dealer:', decoded.id);
    const result = await request.query(query);

    console.log('Risultati query:', JSON.stringify(result.recordset, null, 2));
    
    if (!result.recordset || result.recordset.length === 0) {
      console.log('Nessun risultato dalla query');
      return res.json({ ordini: [] });
    }
    
    return res.json({ ordini: result.recordset });
      
  } catch (err) {
    console.error('Errore in /api/ultimi-ordini:', err);
    // Verifica se la risposta è già stata inviata
    if (!res.headersSent) {
      return res.status(500).json({ 
        error: 'Errore del server', 
        details: err.message,
        code: err.code
      });
    } else {
      console.error('Tentativo di inviare una risposta multipla per la stessa richiesta');
    }
  }
});

// --- API: DOCUMENTAZIONE ---
// GET /api/documentazione
app.get('/api/documentazione', async (req, res) => {
  try {
    // Autenticazione JWT
    const authHeader = req.headers['authorization'];
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token mancante' });
    }
    const token = authHeader.substring(7);
    try {
      jwt.verify(token, 'TUO_JWT_SECRET');
    } catch (err) {
      return res.status(401).json({ error: 'Token non valido' });
    }
    await sql.connect(dbConfig);
    const query = 'SELECT IDFile, Operatore, Titolo, Link FROM dbo.tbFiles ORDER BY Operatore, Titolo';
    const result = await sql.query(query);
    res.json(result.recordset);
  } catch (err) {
    console.error('/api/documentazione error:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});

// --- ECOMMERCE: API PRODOTTI ---
// GET /api/prodotti?segmento=SIM&idOperatore=11
app.get('/api/prodotti', async (req, res) => {
  try {
    // Autenticazione JWT
    const authHeader = req.headers['authorization'];
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token mancante' });
    }
    const token = authHeader.substring(7);
    try {
      jwt.verify(token, 'TUO_JWT_SECRET');
    } catch (err) {
      return res.status(401).json({ error: 'Token non valido' });
    }

    const { segmento, idOperatore } = req.query;
    if (!segmento || !idOperatore) {
      return res.status(400).json({ error: 'Parametro segmento e idOperatore obbligatori' });
    }

    // Mappa FIN -> CELL per la ricerca DB
    let segmentoDb = segmento;
    if (segmento === 'FIN') segmentoDb = 'CELL';

    await sql.connect(dbConfig);
    const request = new sql.Request();
    request.input('segmento', sql.NVarChar, segmentoDb);
    request.input('idOperatore', sql.Int, parseInt(idOperatore, 10));

    const query = `
      SELECT
        IDOfferta AS id,
        Titolo AS nome,
        DescrizioneBreve AS descrizione,
        Crediti AS prezzo,
        LogoLink,
        Segmento AS segmento,
        idOperatore,
        LimiteSIM AS disponibilita,
        Tipo AS categoria,
        ISNULL(SpeseSpedizione, 0) AS SpeseSpedizione
      FROM dbo.tbOfferte
      WHERE tipoOfferta = 4
        AND Segmento = @segmento
        AND idOperatore = @idOperatore
        AND (OnlyFor IS NULL OR OnlyFor = '')
        AND ISNULL(Offerta_Inviata, 1) = 1
        AND ISNULL([ValidaDal], GETDATE()) <= GETDATE()
        AND ISNULL([ValidaAl], GETDATE()) >= GETDATE()
    `;
    const result = await request.query(query);
    res.json(result.recordset);
  } catch (err) {
    console.error('/api/prodotti error:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});

// --- API: TEMPLATE DINAMICO OFFERTA ---
// GET /api/template-offerta/:idOfferta
app.get('/api/template-offerta/:idOfferta', async (req, res) => {
  try {
    // Autenticazione JWT
    const authHeader = req.headers['authorization'];
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token mancante' });
    }
    const token = authHeader.substring(7);
    try {
      jwt.verify(token, 'TUO_JWT_SECRET');
    } catch (err) {
      return res.status(401).json({ error: 'Token non valido' });
    }
    const idOfferta = req.params.idOfferta;
    if (!idOfferta) return res.status(400).json({ error: 'idOfferta obbligatorio' });
    await sql.connect(dbConfig);
    const request = new sql.Request();
    request.input('id', sql.Int, parseInt(idOfferta, 10));
    const query = 'SELECT TemplateDatiOfferta FROM dbo.tbOfferte WHERE IDOfferta = @id';
    const result = await request.query(query);
    if (!result.recordset.length || !result.recordset[0].TemplateDatiOfferta) {
      return res.status(404).json({ error: 'Nome template non trovato per questa offerta' });
    }
    const nomeTemplate = result.recordset[0].TemplateDatiOfferta;
    const fs = require('fs');
    let templatesData;
    try {
      templatesData = fs.readFileSync(__dirname + '/templates.json', 'utf-8');
    } catch (err) {
      return res.status(500).json({ error: 'Impossibile leggere templates.json', details: err.message });
    }
    let templatesArr;
    try {
      templatesArr = JSON.parse(templatesData);
    } catch (err) {
      return res.status(500).json({ error: 'templates.json non valido', details: err.message });
    }
    const template = templatesArr.find(t => t.template === nomeTemplate);
    if (!template) {
      return res.status(404).json({ error: 'Template non trovato in templates.json' });
    }
    res.json(template);
  } catch (err) {
    console.error('/api/template-offerta error:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});

// Endpoint chat semplice per bot
app.post('/webchat', express.json(), async (req, res) => {
  const { text, user_id } = req.body;
  // Qui puoi collegare la tua logica bot, per ora rispondiamo con un echo
  let reply = `Hai scritto: ${text}`;
  // Esempio: if(text.match(/ciao/i)) reply = 'Ciao! Come posso aiutarti?';
  res.json({ reply });
});

// Endpoint per salvare la cronologia chat
app.post('/webchat/history', express.json(), async (req, res) => {
  const { user_id, history } = req.body;
  if (!user_id || !Array.isArray(history)) return res.status(400).json({ error: 'Dati mancanti' });
  try {
    await sql.connect(dbConfig);
    // Upsert: aggiorna se esiste, altrimenti inserisci
    const check = await sql.query`SELECT COUNT(*) as cnt FROM tbChatHistory WHERE UserId = ${user_id}`;
    if (check.recordset[0].cnt > 0) {
      await sql.query`UPDATE tbChatHistory SET History = ${JSON.stringify(history)} WHERE UserId = ${user_id}`;
    } else {
      await sql.query`INSERT INTO tbChatHistory (UserId, History) VALUES (${user_id}, ${JSON.stringify(history)})`;
    }
    res.json({ ok: true });
  } catch (e) {
    res.status(500).json({ error: 'Errore salvataggio cronologia', details: e.message });
  }
});

// Endpoint per recuperare la cronologia chat
app.get('/webchat/history', async (req, res) => {
  const user_id = req.query.user_id;
  if (!user_id) return res.status(400).json({ error: 'user_id mancante' });
  try {
    await sql.connect(dbConfig);
    const result = await sql.query`SELECT TOP 1 History FROM tbChatHistory WHERE UserId = ${user_id}`;
    if (result.recordset.length) {
      res.json({ history: JSON.parse(result.recordset[0].History) });
    } else {
      res.json({ history: [] });
    }
  } catch (e) {
    res.status(500).json({ error: 'Errore recupero cronologia', details: e.message });
  }
});

// Endpoint proxy per gestire le richieste CORS
app.post('/api/proxy/chat', express.json(), async (req, res) => {
  try {
    // Estrai il token JWT dall'header Authorization
    const authHeader = req.headers['authorization'];
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token mancante' });
    }
    
    const token = authHeader.split(' ')[1];
    let decoded;
    
    try {
      decoded = jwt.verify(token, 'TUO_JWT_SECRET');
    } catch (err) {
      return res.status(401).json({ error: 'Token non valido o scaduto' });
    }
    
    // Usa il numero di telefono dal token o 'web_user' come fallback
    const userId = decoded.phoneNumber || 'web_user';
    const { text } = req.body;
    
    if (!text) {
      return res.status(400).json({ error: 'Testo del messaggio mancante' });
    }
    
    console.log(`Inoltro messaggio al bot da ${userId}:`, text);
    
    const response = await axios.post('https://bot.kimweb.agency/from-site', {
      text,
      user_id: userId
    });
    
    res.json(response.data);
  } catch (error) {
    console.error('Errore nella comunicazione con il bot:', error.message);
    res.status(500).json({
      reply: 'Al momento non riesco a contattare il servizio di assistenza. Riprova tra qualche minuto.'
    });
  }
});

app.get('/api/credito-plafond', async (req, res) => {
  console.log('--- /api/credito-plafond chiamato ---');
  try {
    // Verifica token
    const authHeader = req.headers['authorization'];
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      console.error('Errore: Token mancante');
      return res.status(401).json({ error: 'Token mancante' });
    }
    
    const token = authHeader.substring(7);
    let idDealer;
    try {
      const decoded = jwt.verify(token, 'TUO_JWT_SECRET');
      idDealer = decoded.dealerId;
      if (!idDealer) {
        console.error('ID dealer non valido nel token');
        return res.status(401).json({ error: 'ID dealer non valido' });
      }
      console.log('IDDealer estratto dal token:', idDealer);
    } catch (err) {
      console.error('Errore verifica token:', err.message);
      return res.status(401).json({ error: 'Token non valido' });
    }
    
    try {
      // Connessione al database
      await sql.connect(dbConfig);
      const request = new sql.Request();
      // Query per il credito
      request.input('idDealer', sql.Int, idDealer);
      const creditoQuery = `
        SELECT ISNULL(SUM(t.crediti), 0) AS credito
        FROM dbo.tbtransazioni t
        JOIN dbo.tbdealers d ON t.iddealer = d.iddealer
        WHERE d.iddealer = @idDealer
      `;
      
      console.log('Eseguo creditoQuery:', creditoQuery, 'con idDealer:', idDealer);
      const creditoRes = await request.query(creditoQuery);
      console.log('Risultato creditoRes:', JSON.stringify(creditoRes.recordset, null, 2));
      
      const credito = creditoRes.recordset[0].credito || 0;
      console.log('Credito calcolato:', credito);
      
      res.json({ credito });
    } catch (err) {
      console.error('ERRORE /api/credito-plafond:', err.message, err.stack, err);
      res.status(500).json({ error: 'Errore server', details: err.message, stack: err.stack });
    }
  } catch (err) {
    console.error('ERRORE GRAVE /api/credito-plafond:', err.message, err.stack, err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});

// Endpoint per ottenere gli operatori principali (con SKY raggruppato)
app.get('/api/operatori', async (req, res) => {
  try {
    // Autenticazione JWT
    const authHeader = req.headers['authorization'];
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token mancante' });
    }
    const token = authHeader.split(' ')[1];
    try {
      jwt.verify(token, 'TUO_JWT_SECRET');
    } catch (err) {
      return res.status(401).json({ error: 'Token non valido' });
    }

    await sql.connect(dbConfig);
    
    // Ottieni tutti gli operatori tranne quelli esclusi
    const result = await sql.query`
      SELECT IDOperatore as id, Denominazione as nome, 
             CASE WHEN IDOperatore IN (3, 8, 12, 14) THEN 1 ELSE 0 END as isSky
      FROM dbo.tbOperatori2 
      WHERE IDOperatore NOT IN (4, 10, 11)  -- Escludi RABONA, ASSISTENZA, PRODOTTI
      ORDER BY isSky DESC, Denominazione`;
    
    // Raggruppa gli operatori SKY in un unico oggetto
    const operatori = [];
    const skyOperators = [];
    
    result.recordset.forEach(op => {
      if (op.isSky) {
        skyOperators.push({
          id: op.id,
          nome: op.nome
        });
      } else {
        operatori.push({
          id: op.id,
          nome: op.nome
        });
      }
    });
    
    // Aggiungi l'opzione SKY all'inizio
    if (skyOperators.length > 0) {
      operatori.unshift({
        id: 'SKY',
        nome: 'SKY',
        isSkyGroup: true
      });
    }
    
    res.json(operatori);
  } catch (err) {
    console.error('Errore in /api/operatori:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  } finally {
    sql.close();
  }
});

// Endpoint per ottenere i sottotipi SKY
app.get('/api/sky-tipi', async (req, res) => {
  // TODO: implementare endpoint reale se necessario
  res.json([]);
});

// Endpoint per ottenere le tipologie disponibili per un operatore
app.get('/api/tipologie', async (req, res) => {
  try {
    // Autenticazione JWT
    const authHeader = req.headers['authorization'];
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token mancante' });
    }
    const token = authHeader.split(' ')[1];
    try {
      jwt.verify(token, 'TUO_JWT_SECRET');
    } catch (err) {
      return res.status(401).json({ error: 'Token non valido' });
    }

    const { operatore } = req.query;
    if (!operatore) {
      return res.status(400).json({ error: 'Parametro operatore obbligatorio' });
    }
    await sql.connect(dbConfig);

    // Ricava tutte le tipologie disponibili per quell’operatore dalle offerte attive
    let result;
    if (parseInt(operatore) === 6) {
      // KENA MOBILE: nessun filtro aggiuntivo
      result = await sql.query`
        SELECT DISTINCT
          CASE
            WHEN o.Segmento = 'RES' THEN 'RESIDENZIALE'
            WHEN o.Segmento = 'SHP' THEN 'BUSINESS'
            ELSE o.Segmento
          END AS tipologia
        FROM dbo.tbOfferte o
        WHERE o.idOperatore = 6
      `;
    } else {
      result = await sql.query`
        SELECT DISTINCT
          CASE
            WHEN o.Segmento = 'RES' THEN 'RESIDENZIALE'
            WHEN o.Segmento = 'SHP' THEN 'BUSINESS'
            ELSE o.Segmento
          END AS tipologia
        FROM dbo.tbOfferte o
        WHERE o.idOperatore = ${parseInt(operatore)}
          AND o.Segmento != 'FIN'
          AND (o.OnlyFor IS NULL OR o.OnlyFor = '')
          AND ISNULL(o.Offerta_Inviata, 1) = 1
          AND ISNULL(o.ValidaDal, GETDATE()) <= GETDATE()
          AND ISNULL(o.ValidaAl, GETDATE()) >= GETDATE()
      `;
    }
    const tipologie = result.recordset.map(r => r.tipologia);
    res.json(tipologie);
  } catch (err) {
    console.error('Errore in /api/tipologie:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  } finally {
    sql.close();
  }
});
// Endpoint per ottenere le offerte filtrate per operatore e tipologia
app.get('/api/offerte', async (req, res) => {
  try {
    // Autenticazione JWT
    const authHeader = req.headers['authorization'];
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token mancante' });
    }
    const token = authHeader.split(' ')[1];
    try {
      jwt.verify(token, 'TUO_JWT_SECRET');
    } catch (err) {
      return res.status(401).json({ error: 'Token non valido' });
    }

    const { operatore, tipologia, segmento } = req.query;
    
    // Se c'è il parametro segmento, usa la logica per i prodotti
    if (segmento) {
      return await getProdottiBySegmento(req, res, segmento);
    }
    
    // Altrimenti usa la logica originale per le offerte
    if (!operatore) {
      return res.status(400).json({ error: 'Parametro operatore obbligatorio' });
    }

    await sql.connect(dbConfig);
    let query = '';
    const operatorId = parseInt(operatore);
    if (req.query.from === 'attivazioni') {
      if ([3, 8, 12, 14].includes(operatorId) && tipologia) {
        // SKY su attivazioni
        query = `
          SELECT  
            o.IDOfferta,
            op.Denominazione AS NomeOperatore,
            o.LogoLink,
            o.Titolo,
            o.DescrizioneBreve,
            o.Crediti,
            o.idOperatore,
            o.Segmento,
            o.LogoLink AS LogoOperatore,
            o.TemplateDatiOfferta,
            o.LimiteSIM AS disponibilita,
            o.Tipo AS categoria
          FROM dbo.tbOfferte o
          INNER JOIN dbo.tbOperatori2 op ON o.idOperatore = op.IDOperatore
          WHERE o.idOperatore = ${operatorId}
            AND o.Segmento = '${tipologia}'
            AND ISNULL(o.ValidaDal, GETDATE()) <= GETDATE()
            AND ISNULL(o.ValidaAl, GETDATE()) >= GETDATE()
            AND op.IDOperatore IS NOT NULL
          ORDER BY o.Crediti ASC`;
      } else {
        // ATTIVAZIONI per altri operatori: mostra solo offerte con Segmento RES o BUS
        query = `
          SELECT  
            o.IDOfferta,
            op.Denominazione AS NomeOperatore,
            o.LogoLink,
            o.Titolo,
            o.DescrizioneBreve,
            o.Crediti,
            o.idOperatore,
            o.Segmento,
            o.LogoLink AS LogoOperatore,
            o.TemplateDatiOfferta,
            o.LimiteSIM AS disponibilita,
            o.Tipo AS categoria
          FROM dbo.tbOfferte o
          INNER JOIN dbo.tbOperatori2 op ON o.idOperatore = op.IDOperatore
          WHERE o.idOperatore = ${operatorId}
            AND (o.Segmento = 'RES' OR o.Segmento = 'BUS')
            AND ISNULL(o.ValidaDal, GETDATE()) <= GETDATE()
            AND ISNULL(o.ValidaAl, GETDATE()) >= GETDATE()
            AND op.IDOperatore IS NOT NULL
          ORDER BY o.Crediti ASC`;
      }
    } else {
      // Pagina assistenza: solo offerte SOS
      query = `
        SELECT  
          o.IDOfferta,
          op.Denominazione AS NomeOperatore,
          o.LogoLink,
          o.Titolo,
          o.DescrizioneBreve,
          o.Crediti,
          o.idOperatore,
          o.Segmento,
          o.LogoLink AS LogoOperatore,
          o.TemplateDatiOfferta,
          o.LimiteSIM AS disponibilita,
          o.Tipo AS categoria
        FROM dbo.tbOfferte o
        INNER JOIN dbo.tbOperatori2 op ON o.idOperatore = op.IDOperatore
        WHERE o.idOperatore = ${operatorId}
          AND o.Tipo = 'SOS'
          AND ISNULL(o.ValidaDal, GETDATE()) <= GETDATE()
          AND ISNULL(o.ValidaAl, GETDATE()) >= GETDATE()
          AND op.IDOperatore IS NOT NULL
        ORDER BY o.Crediti ASC`;
    }
    console.log('Esecuzione query offerte:', query);
    const result = await sql.query(query);
    res.json(result.recordset);
  } catch (err) {
    console.error('Errore in /api/offerte:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  } finally {
    sql.close();
  }
});

// Funzione per ottenere i prodotti filtrati per segmento (SIM o TELEFONI)
async function getProdottiBySegmento(req, res, segmento) {
  try {
    await sql.connect(dbConfig);
    
    // Mappa i segmenti richiesti ai valori nel database
    let query = '';
    let params = {};
    
    if (segmento === 'SIM') {
      query = `
        SELECT
          o.IDOfferta AS id,
          o.Titolo AS nome,
          o.DescrizioneBreve AS descrizione,
          o.Crediti AS prezzo,
          o.LogoLink,
          o.Segmento,
          o.idOperatore,
          o.LimiteSIM AS disponibilita,
          o.Tipo AS categoria,
          op.Denominazione AS NomeOperatore
        FROM dbo.tbOfferte o
        INNER JOIN dbo.tbOperatori2 op ON o.idOperatore = op.IDOperatore
        WHERE o.tipoOfferta = 4
          AND o.Segmento = 'SIM'
          AND (o.OnlyFor IS NULL OR o.OnlyFor = '')
          AND ISNULL(o.Offerta_Inviata, 1) = 1
          AND ISNULL(o.ValidaDal, GETDATE()) <= GETDATE()
          AND ISNULL(o.ValidaAl, GETDATE()) >= GETDATE()
        ORDER BY o.Titolo`;
    } else if (segmento === 'FIN') { // TELEFONI
      query = `
        SELECT
          o.IDOfferta AS id,
          o.Titolo AS nome,
          o.DescrizioneBreve AS descrizione,
          o.Crediti AS prezzo,
          o.LogoLink,
          o.Segmento,
          o.idOperatore,
          o.LimiteSIM AS disponibilita,
          o.Tipo AS categoria,
          op.Denominazione AS NomeOperatore
        FROM dbo.tbOfferte o
        INNER JOIN dbo.tbOperatori2 op ON o.idOperatore = op.IDOperatore
        WHERE o.tipoOfferta = 4
          AND o.Segmento = 'CELL'
          AND o.idOperatore = 11
          AND (o.OnlyFor IS NULL OR o.OnlyFor = '')
          AND ISNULL(o.Offerta_Inviata, 1) = 1
          AND ISNULL(o.ValidaDal, GETDATE()) <= GETDATE()
          AND ISNULL(o.ValidaAl, GETDATE()) >= GETDATE()
        ORDER BY o.Titolo`;
    } else {
      return res.status(400).json({ error: 'Segmento non valido' });
    }

    console.log('Esecuzione query prodotti per segmento:', segmento);
    const result = await sql.query(query);
    
    res.json(result.recordset);
  } catch (err) {
    console.error('Errore nel recupero prodotti per segmento:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  } finally {
    sql.close();
  }
}

app.get('/api/andamento', async (req, res) => {
  try {
    console.log('Richiesta ricevuta su /api/andamento');
    
    // Autenticazione JWT
    const authHeader = req.headers['authorization'];
    console.log('Authorization header:', authHeader ? 'presente' : 'mancante');
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      console.log('Formato token non valido');
      return res.status(401).json({ error: 'Token non fornito o non valido' });
    }
    
    const token = authHeader.split(' ')[1];
    console.log('Token ricevuto:', token ? 'presente' : 'mancante');
    
    let decoded;
    try {
      // Verifica il token con il segreto corretto
      decoded = jwt.verify(token, 'TUO_JWT_SECRET');
      console.log('Token decodificato:', decoded);
    } catch (err) {
      console.error('Errore durante la verifica del token:', err.message);
      return res.status(401).json({ 
        error: 'Token non valido o scaduto',
        details: err.message 
      });
    }
    
    await sql.connect(dbConfig);
    const result = await sql.query`
      WITH MonthlyData AS (
        SELECT 
          FORMAT(ord.DataStato, 'yyyy/MM') AS [ANNO_MESE],
          d.RagioneSociale AS Point,
          SUM(CASE WHEN o.IDOPERATORE = 5 THEN 1 ELSE 0 END) AS ILIAD,
          SUM(CASE WHEN o.IDOPERATORE = 6 THEN 1 ELSE 0 END) AS KENA,
          SUM(CASE WHEN o.IDOPERATORE = 7 THEN 1 ELSE 0 END) AS [1MOBILE],
          SUM(CASE WHEN o.IDOPERATORE = 13 THEN 1 ELSE 0 END) AS WEEDOO
        FROM 
          dbo.tbOFFERTE o
          JOIN dbo.tbordini ord ON o.IDOFFERTA = ord.IDOFFERTA
          JOIN dbo.tbDealers d ON ord.iddealer = d.idDealer
        WHERE 
          o.IDOPERATORE IN (4, 5, 6, 7, 13)
          AND d.idDealer = ${decoded.dealerId}
          AND ord.Stato = '1'
        GROUP BY 
          FORMAT(ord.DataStato, 'yyyy/MM'), d.RagioneSociale
      ),
      MonthlyTotals AS (
        SELECT 
          FORMAT(ord.DataStato, 'yyyy/MM') AS [ANNO_MESE],
          'TOTALE ' + UPPER(FORMAT(ord.DataStato, 'MMMM', 'it-IT')) AS Point,
          SUM(CASE WHEN o.IDOPERATORE = 5 THEN 1 ELSE 0 END) AS ILIAD,
          SUM(CASE WHEN o.IDOPERATORE = 6 THEN 1 ELSE 0 END) AS KENA,
          SUM(CASE WHEN o.IDOPERATORE = 7 THEN 1 ELSE 0 END) AS [1MOBILE],
          SUM(CASE WHEN o.IDOPERATORE = 13 THEN 1 ELSE 0 END) AS WEEDOO
        FROM 
          dbo.tbOFFERTE o
          JOIN dbo.tbordini ord ON o.IDOFFERTA = ord.IDOFFERTA
          JOIN dbo.tbDealers d ON ord.iddealer = d.idDealer
        WHERE 
          o.IDOPERATORE IN (4, 5, 6, 7, 13)
          AND d.idDealer = ${decoded.dealerId}
        GROUP BY 
          FORMAT(ord.DataStato, 'yyyy/MM'), FORMAT(ord.DataStato, 'MMMM', 'it-IT')
      )
      SELECT 
        [ANNO_MESE] AS ANNO_MESE,
        Point,
        ISNULL(ILIAD, 0) AS ILIAD,
        ISNULL(KENA, 0) AS KENA,
        ISNULL([1MOBILE], 0) AS [1MOBILE],
        ISNULL(WEEDOO, 0) AS WEEDOO
      FROM (
        SELECT 
          [ANNO_MESE],
          Point,
          ILIAD,
          KENA,
          [1MOBILE],
          WEEDOO,
          0 AS SortOrder
        FROM MonthlyTotals
      
        UNION ALL
      
        SELECT 
          [ANNO_MESE],
          Point,
          ILIAD,
          KENA,
          [1MOBILE],
          WEEDOO,
          1 AS SortOrder
        FROM MonthlyData
      ) AS CombinedData
      ORDER BY 
        [ANNO_MESE] DESC,
        SortOrder,
        CASE WHEN Point LIKE 'TOTALE%' THEN 0 ELSE 1 END,
        Point`;

    res.json(result.recordset);
  } catch (err) {
    console.error('Errore nel recupero dei dati di andamento:', err);
    res.status(500).json({ error: 'Errore nel recupero dei dati di andamento', details: err.message });
  }
});

// --- API: OBIETTIVI ---
// GET /api/obiettivi
app.get('/api/obiettivi', async (req, res) => {
  let fastwebStats = {}; // Spostato qui per renderlo disponibile in tutto lo scope
  
  try {
    // 1️⃣ Auth e validazione
    const authHeader = req.headers['authorization'];
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token mancante' });
    }

    const token = authHeader.split(' ')[1];
    let decoded;
    try {
      decoded = jwt.verify(token, 'TUO_JWT_SECRET');
      if (!decoded.dealerId) {
        return res.status(401).json({ error: 'Token non valido: dealerId mancante' });
      }
    } catch (err) {
      return res.status(401).json({ error: 'Token non valido o scaduto' });
    }

    const idDealer = parseInt(decoded.dealerId, 10);
    if (isNaN(idDealer)) {
      return res.status(401).json({ error: 'ID dealer non valido' });
    }

    // 2️⃣ Anno / Mese attuale
    const now = new Date();
    const anno = now.getFullYear();
    const mese = now.getMonth() + 1;

    // 3️⃣ Connessione al database
    await sql.connect(dbConfig);
    
    // 3️⃣ Leggi tutte le soglie_report
    const request = new sql.Request();
    request.input('anno', sql.Int, anno);
    request.input('mese', sql.Int, mese);

    const soglieRes = await request.query(`
      SELECT operatore, categoria, segmento, 
             soglia_1_min, soglia_1_max, 
             soglia_2_min, soglia_2_max, 
             soglia_3_min, soglia_3_max, 
             soglia_4_min, soglia_4_max 
      FROM soglie_report 
      WHERE anno = @anno AND mese = @mese`);

    const soglie = soglieRes.recordset;

    // 5️⃣ Funzione helper per calcolare il target e i mancanti
    const calcolaMancano = (attuale, sogliaRow) => {
      const soglieOrdered = [
        sogliaRow.soglia_1_max,
        sogliaRow.soglia_2_max,
        sogliaRow.soglia_3_max,
        sogliaRow.soglia_4_max
      ].filter(s => s != null);
      
      for (const sogliaMax of soglieOrdered) {
        if (attuale < sogliaMax) {
          return Math.max(0, sogliaMax - attuale);
        }
      }
      return 0;
    };

    const getTarget = (attuale, sogliaRow) => {
      const soglieOrdered = [
        sogliaRow.soglia_1_max,
        sogliaRow.soglia_2_max,
        sogliaRow.soglia_3_max,
        sogliaRow.soglia_4_max
      ].filter(x => x != null);
      
      for (const sogliaMax of soglieOrdered) {
        if (attuale < sogliaMax) {
          return sogliaMax;
        }
      }
      return soglieOrdered[soglieOrdered.length - 1] || 0;
    };

    // 6️⃣ Carichiamo i dati per ogni operatore
    
    // 1. Fastweb TLC
    try {
      console.log('Esecuzione query GetOrderStatisticsByDealerByidDealer per idDealer:', idDealer);
      const fastwebStatsRes = await sql.query`EXEC GetOrderStatisticsByDealerByidDealer @idDealer = ${idDealer}`;
      fastwebStats = fastwebStatsRes.recordset[0] || {};
      console.log('Risultati Fastweb TLC:', JSON.stringify(fastwebStats, null, 2));
      
      // Log delle soglie trovate per Fastweb TLC
      const soglieFastweb = soglie.filter(s => s.operatore === 'Fastweb' && s.categoria !== 'ENERGIA');
      console.log('Soglie trovate per Fastweb TLC:', JSON.stringify(soglieFastweb, null, 2));
    } catch (error) {
      console.error('Errore durante l\'esecuzione di GetOrderStatisticsByDealerByidDealer:', error);
      fastwebStats = {};
    }

    const mappaCategorieFastweb = {
      'MOBILE RES': fastwebStats['MOBILI RES'] || 0,
      'MOBILE SHP': fastwebStats['MOBILI BUS'] || 0,
      'FISSO RES': fastwebStats['FISSI RES'] || 0,
      'FISSO SHP': fastwebStats['FISSI BUS'] || 0,
      'Convergenza RES': fastwebStats['di cui CONV_RES'] || 0,
      'Convergenza SHP': fastwebStats['di cui CONV_BUS'] || 0
    };

    const categorieFastweb = soglie
      .filter(s => s.operatore === 'Fastweb' && s.categoria !== 'ENERGIA')
      .map(s => {
        const nomeCategoria = `${s.categoria} ${s.segmento}`.trim();
        const attuale = mappaCategorieFastweb[nomeCategoria] || 0;
        const target = getTarget(attuale, s);
        const mancano = calcolaMancano(attuale, s);

        return { nome: nomeCategoria, attuale, target, mancano };
      });

    // 2. Fastweb ENERGIA
    const energiaRes = await sql.query`
      EXEC ReportContrattiEnergiaPeridDealer @idDealer = ${idDealer}`;
    const energiaStats = energiaRes.recordset[0] || {};

    const energiaAttualeRES = energiaStats['Segmento RES'] || 0;
    const energiaAttualeSHP = energiaStats['Segmento BUS'] || 0;

    const categorieEnergia = [];

    const sogliaEnergiaRES = soglie.find(s => s.operatore === 'Fastweb' && s.categoria === 'ENERGIA' && s.segmento === 'RES');
    if (sogliaEnergiaRES) {
      categorieEnergia.push({
        nome: 'Energia RES',
        attuale: energiaAttualeRES,
        target: getTarget(energiaAttualeRES, sogliaEnergiaRES),
        mancano: calcolaMancano(energiaAttualeRES, sogliaEnergiaRES)
      });
    }

    const sogliaEnergiaSHP = soglie.find(s => s.operatore === 'Fastweb' && s.categoria === 'ENERGIA' && s.segmento === 'SHP');
    if (sogliaEnergiaSHP) {
      categorieEnergia.push({
        nome: 'Energia SHP',
        attuale: energiaAttualeSHP,
        target: getTarget(energiaAttualeSHP, sogliaEnergiaSHP),
        mancano: calcolaMancano(energiaAttualeSHP, sogliaEnergiaSHP)
      });
    }

    // 3. Sky Mobile & WIFI
    const skyMobileWifiRes = await sql.query`
      EXEC ReportAttivazioniSkyMobileWifibyIddealer @idDealer = ${idDealer}`;
    const skyMobileWifiStats = skyMobileWifiRes.recordset[0] || {};

    const mappaSkyMobileWifi = {
      'MOBILE': skyMobileWifiStats['MOBILE'] || 0,
      'WIFI': skyMobileWifiStats['WIFI'] || 0
    };

    const categorieSkyMobileWifi = Object.keys(mappaSkyMobileWifi).map(cat => {
      const attuale = mappaSkyMobileWifi[cat];
      const sogliaRow = soglie.find(s => s.operatore === 'Sky Mobile & WIFI' && s.categoria === cat);
      const target = sogliaRow ? getTarget(attuale, sogliaRow) : 0;
      const mancano = sogliaRow ? calcolaMancano(attuale, sogliaRow) : 0;

      return { nome: cat, attuale, target, mancano };
    });

    // 4. Sky TV
    const skyTvRes = await sql.query`
      EXEC ReportAttivazioniSkyTV @idDealer = ${idDealer}`;
    const skyTvStats = skyTvRes.recordset[0] || {};

    const mappaSkyTv = {
      'ONLY TV': skyTvStats['ONLY TV'] || 0,
      '3P': skyTvStats['3P'] || 0,
      'GLASS': skyTvStats['GLASS'] || 0,
      '3P GLASS': skyTvStats['3P GLASS'] || 0
    };

    const categorieSkyTv = Object.keys(mappaSkyTv).map(cat => {
      const attuale = mappaSkyTv[cat];
      const sogliaRow = soglie.find(s => s.operatore === 'Sky TV' && s.categoria === cat);
      const target = sogliaRow ? getTarget(attuale, sogliaRow) : 0;
      const mancano = sogliaRow ? calcolaMancano(attuale, sogliaRow) : 0;

      return { nome: cat, attuale, target, mancano };
    });

    // 7️⃣ Prepara la risposta finale
    const risposta = {
      obiettivi: [
        { operatore: 'Fastweb TLC', categorie: categorieFastweb },
        { operatore: 'Fastweb ENERGIA', categorie: categorieEnergia },
        { operatore: 'Sky Mobile & WIFI', categorie: categorieSkyMobileWifi },
        { operatore: 'Sky TV', categorie: categorieSkyTv }
      ]
    };


    res.json(risposta);
  } catch (err) {
    console.error('Errore in /api/obiettivi:', err);
    res.status(500).json({ error: 'Errore nel recupero degli obiettivi', details: err.message });
  } finally {
    sql.close();
  }

});
