import dotenv from 'dotenv';
console.log('=== SERVER AVVIATO ===');
import multer from 'multer';
import path from 'path';
import { fileURLToPath } from 'url';
import express from 'express';
import { DateTime } from 'luxon';
import sql from 'mssql';
import { createRequire } from 'module';
import axios from 'axios';
import https from 'https';
import jwt from 'jsonwebtoken';
import Stripe from 'stripe';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Carica le variabili d'ambiente
const result = dotenv.config({ path: path.join(__dirname, '.env') });
console.log('[DEBUG][STRIPE] Chiave usata:', process.env.STRIPE_SECRET_KEY);
console.log('[DEBUG] dotenv result:', result);
console.log('[DEBUG] Stripe key (raw):', process.env.STRIPE_SECRET_KEY);
console.log('[DEBUG] Stripe key (masked):', process.env.STRIPE_SECRET_KEY ? process.env.STRIPE_SECRET_KEY.slice(0, 8) + '...' + process.env.STRIPE_SECRET_KEY.slice(-4) : 'undefined');
console.log('[DEBUG] Stripe key (hex):', Buffer.from(process.env.STRIPE_SECRET_KEY || '', 'utf8').toString('hex'));

// Configura axios per non verificare i certificati SSL
axios.defaults.httpsAgent = new https.Agent({  
  rejectUnauthorized: false
});

// Crea require per i moduli CommonJS
const require = createRequire(import.meta.url);
const aspnetIdentityPw = require('aspnet-identity-pw');
console.log('aspnetIdentityPw export:', aspnetIdentityPw);
console.log('aspnetIdentityPw.validatePassword:', typeof aspnetIdentityPw.validatePassword);

// Verifica chiave Stripe
if (!process.env.STRIPE_SECRET_KEY) {
  console.error('[FATAL] STRIPE_SECRET_KEY non definita! Arresto server.');
  process.exit(1);
}

const stripeKey = process.env.STRIPE_SECRET_KEY;
console.log('[DEBUG] Stripe Secret Key (masked):', stripeKey ? stripeKey.slice(0, 8) + '...' + stripeKey.slice(-4) : 'undefined');
console.log('[DEBUG] Stripe Secret Key (hex):', Buffer.from(stripeKey || '', 'utf8').toString('hex'));
const stripe = new Stripe(stripeKey);
let sqlErrorListenerAdded = false;

// Configurazione del database
const dbConfig = {
  user: process.env.DB_USER || 'sa',
  password: process.env.DB_PASSWORD || '1RUDfS;1LS!u%CvWm',
  server: process.env.DB_SERVER || '54.155.32.254',
  port: parseInt(process.env.DB_PORT || '1433'),
  database: process.env.DB_NAME || 'KIM_STAGING',
  options: {
    encrypt: false,
    trustServerCertificate: true,
    enableArithAbort: true,
    connectTimeout: 15000,
    requestTimeout: 15000,
    validateBulkLoadParameters: false,
    useUTC: false,
    abortTransactionOnError: false,
    enableAnsiNullDefault: true,
    appName: 'kim-backend',
    cryptoCredentialsDetails: {
      minVersion: 'TLSv1.2'
    }
  }
};

// Funzione per la connessione al database
async function connectToDatabase() {
  try {
    if (!sql.connected) {
      console.log('Tentativo di connessione al database...');
      await sql.connect(dbConfig);
      console.log('Connessione al database stabilita con successo');
      
      // Aggiungi il listener di errori solo una volta
      if (!sqlErrorListenerAdded) {
        sql.on('error', err => {
          console.error('Errore persistente di connessione al database (sql.on(error)):', err);
        });
        sqlErrorListenerAdded = true;
      }
    }
    return true;
  } catch (err) {
    console.error('Errore durante la connessione al database:', err);
    return false;
  }
}

// --- PUBLIC ROUTES (no JWT required) ---
const PUBLIC_ROUTES = [
  '/api/login',
  '/api/test-password',
  '/health',
  '/api/password-reset-request',
  '/api/password-reset-confirm',
  '/api/reset-password', // compatibilità frontend
  '/api/reset-password/', // accetta anche slash finale
];

// Middleware per l'autenticazione del token JWT
function authenticateToken(req, res, next) {
  // Debug: log path for troubleshooting
  console.log('[AUTH DEBUG] Path richiesta:', req.path);
  // Allow public routes (match any path that starts with a public route)
  if (PUBLIC_ROUTES.some(route => req.path === route || req.path.startsWith(route))) return next();
  // Allow public routes without JWT
  if (PUBLIC_ROUTES.includes(req.path)) return next();
  // --- DEBUG: Middleware caricato, versione ---
  if (!global._auth_debug_logged) {
    console.log('[AUTH DEBUG] Funzione authenticateToken caricata:', authenticateToken.toString().slice(0, 300));
    global._auth_debug_logged = true;
  }
  console.log('[AUTH DEBUG] Middleware chiamato, header Authorization:', req.headers['authorization']);
  const authHeader = req.headers['authorization'];
  console.log('[AUTH] authHeader:', authHeader); // LOG 1
  const token = authHeader && authHeader.split(' ')[1];
  console.log('[AUTH] Token estratto:', token); // LOG 2
  console.log('[AUTH] JWT_SECRET usata per VERIFICARE:', process.env.JWT_SECRET); // LOG 3

  if (token == null) {
    console.log('[AUTH] Token nullo, invio 401');
    return res.sendStatus(401);
  }

  try {
    const user = jwt.verify(token, process.env.JWT_SECRET);
    console.log('[AUTH DEBUG] Payload decodificato:', JSON.stringify(user, null, 2));
    console.log('[AUTH] Token verificato con successo, utente:', user.email);
    
    // Assicurati che l'oggetto utente abbia la struttura attesa
    req.user = {
      ...user,
      // Assicurati che ruoli sia sempre un array
      ruoli: Array.isArray(user.ruoli) ? user.ruoli : [user.ruoli].filter(Boolean)
    };
    
    console.log('[AUTH] Utente impostato su req.user:', JSON.stringify(req.user, null, 2));
    next();
  } catch (err) {
    console.error('[AUTH] Errore jwt.verify:', err.message); // LOG 4
    console.error('[AUTH] Token che ha fallito la verifica:', token); // LOG 5
    console.error('[AUTH] Chiave usata per la verifica che ha fallito:', process.env.JWT_SECRET); // LOG 6
    return res.sendStatus(403); // se il token non è valido, proibito
  }
}

// Crea l'applicazione Express
const app = express();
n// Rotta di test
app.get('/test-route', (req, res) => {
  console.log('Test route chiamata');
  res.json({ ok: true, message: 'Test route funzionante' });
});

// Middleware: solo MASTER
function onlyMaster(req, res, next) {
  console.log('=== ONLY_MASTER MIDDLEWARE ===');
  try {
    if (!req.user) {
      console.log('[ONLY_MASTER] Errore: Utente non autenticato');
      return res.status(403).json({ error: 'Accesso non autorizzato' });
    }
    
    const ruoli = req.user.ruoli ? req.user.ruoli.map(r => r.toUpperCase()) : [];
    console.log('[ONLY_MASTER] Ruoli utente:', ruoli);
    
    if (ruoli.includes('MASTER') || req.user.email === 'attivazioni@kimweb.it') {
      console.log('[ONLY_MASTER] Accesso consentito');
      return next();
    }
    
    console.log('[ONLY_MASTER] Accesso negato: ruolo non autorizzato');
    return res.status(403).json({ error: 'Accesso riservato al ruolo MASTER' });
  } catch (e) {
    console.error('[ONLY_MASTER] Errore:', e);
    return res.status(403).json({ error: 'Errore di autorizzazione' });
  }
}

// Esporta i middleware per l'uso in altri file
export { onlyMaster, authenticateToken };

// Middleware: solo MASTERPRODOTTI
function onlyMasterProdotti(req, res, next) {
  console.log('=== ONLY_MASTER MIDDLEWARE ===');
  try {
    if (!req.user) {
      console.log('[ONLY_MASTERPRODOTTI] Errore: Utente non autenticato');
      return res.status(403).json({ error: 'Accesso non autorizzato' });
    }
    
    const ruoli = req.user.ruoli ? req.user.ruoli.map(r => r.toUpperCase()) : [];
    console.log('[ONLY_MASTERPRODOTTI] Ruoli utente:', ruoli);
    
    if (ruoli.includes('MASTERPRODOTTI') || req.user.email === 'amministrazione@kimweb.it') {
      console.log('[ONLY_MASTERPRODOTTI] Accesso consentito');
      return next();
    }
    
    console.log('[ONLY_MASTERPRODOTTI] Accesso negato: ruolo non autorizzato');
    return res.status(403).json({ error: 'Accesso riservato al ruolo MASTERPRODOTTI' });
  } catch (e) {
    console.error('[ONLY_MASTERPRODOTTI] Errore:', e);
    return res.status(403).json({ error: 'Errore di autorizzazione' });
  }
}

// Endpoint: ORDINI MasterProdotti
app.get('/api/masterprodotti/ordini', authenticateToken, onlyMasterProdotti, async (req, res) => {
  try {
    await sql.connect(dbConfig);
    const result = await sql.query(`
      SELECT 
        FORMAT(o.[DataOra], 'dd.MM.yy') AS [Data],
        d.[RagioneSociale],
        o.[TotaleOrdine],
        o.[NoteOrdine] AS [NOTE],
        s.[StatoEsteso]
      FROM 
        [dbo].[tbOrdiniProdotti] o
      INNER JOIN 
        [dbo].[tbDealers] d ON o.[idDealer] = d.[idDealer]
      INNER JOIN 
        [dbo].[tbStatiOrdiniProdotti] s ON o.[idStatoOrdineProdotto] = s.[IDStato]
      ORDER BY 
        o.[DataOra] DESC;
    `);
    return res.json(result.recordset || []);
  } catch (err) {
    console.error('[MASTERPRODOTTI][ORDINI] Errore:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});
// Endpoint: ATTIVAZIONI MasterProdotti
app.get('/api/masterprodotti/attivazioni', authenticateToken, onlyMasterProdotti, async (req, res) => {
  try {
    await sql.connect(dbConfig);
    const result = await sql.query(`
      SELECT TOP 50
        o.IDOrdine,
        FORMAT(o.DataOra, 'dd/MM/yyyy HH:mm') as DataOrdine,
        o.Stato,
        d.RagioneSociale as Dealer,
        o.NomeOfferta as Offerta
      FROM dbo.tbOrdini o
      LEFT JOIN dbo.tbDealers d ON o.idDealer = d.IDDealer
      ORDER BY o.DataOra DESC
    `);
    
    // Mappa gli stati per rimuovere eventuali caratteri speciali
    const attivazioni = result.recordset.map(item => ({
      ...item,
      // Assicurati che lo stato sia nel formato atteso dal frontend
      Stato: item.Stato ? item.Stato.replace(/[^\w\s]/gi, '').replace(/\s+/g, ' ').trim() : ''
    }));
    
    res.json(attivazioni);

  } catch (err) {
    console.error('[MASTERPRODOTTI][ATTIVAZIONI] Errore:', err);
    res.status(500).json({ error: 'Errore nel recupero delle attivazioni' });
  }
});

// --- Password Reset Token Store (in-memory, replace with DB in production) ---
const passwordResetTokens = new Map(); // email -> { token, expires, used }

// --- Nodemailer Setup (reuse your existing config) ---
import nodemailer from 'nodemailer';
const transporter = nodemailer.createTransport({
  host: process.env.EMAIL_HOST,
  port: parseInt(process.env.EMAIL_PORT || '587'),
  secure: process.env.EMAIL_SECURE === 'true',
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASSWORD,
  },
});

// --- PASSWORD RESET ENDPOINTS ---

// Alias per compatibilità frontend: /api/reset-password
app.post('/api/reset-password', express.json(), async (req, res, next) => {
  // Forward alla stessa logica di /api/password-reset-request
  req.url = '/api/password-reset-request';
  app._router.handle(req, res, next);
});

// 1. Request password reset (send email)
app.post('/api/password-reset-request', express.json(), async (req, res) => {
  const { email } = req.body;
  if (!email) return res.status(400).json({ error: 'Email richiesta' });
  try {
    await sql.connect(dbConfig);
    // Check if user exists
    const userRes = await new sql.Request()
      .input('email', sql.NVarChar, email)
      .query('SELECT TOP 1 * FROM dbo.AspNetUsers WHERE Email = @email');
    if (!userRes.recordset.length) {
      // Don't reveal if email exists (security)
      return res.json({ success: true });
    }
    // Generate a secure random token
    const token = (Math.random().toString(36).slice(2) + Math.random().toString(36).slice(2)).slice(0, 32);
    const expires = Date.now() + 1000 * 60 * 30; // 30 min expiry
    passwordResetTokens.set(email, { token, expires, used: false });
    // Send email
    // Nuova logica: link verso la pagina moderna di reset password
    const resetLink = `${process.env.FRONTEND_URL || 'http://localhost:3000'}/reset-password.html?token=${token}&email=${encodeURIComponent(email)}`;
    await transporter.sendMail({
      from: 'kimstation.noreply@kimweb.agency',
      to: 'comunicazioni@kimweb.it', // OVERRIDE for testing, always send here
      // In production, use: to: email,
      subject: 'Password Reset Request',
      html: `<p>Per reimpostare la password, clicca qui: <a href="${resetLink}">${resetLink}</a><br>Il link scade in 30 minuti.</p>`
    });
    return res.json({ success: true });
  } catch (err) {
    console.error('[RESET] Errore richiesta reset:', err);
    return res.status(500).json({ error: 'Errore server' });
  }
});

// --- ENDPOINT DASHBOARD MASTER ---

// Endpoint: ORDINI MasterProdotti
app.get('/api/masterprodotti/ordini', authenticateToken, onlyMasterProdotti, async (req, res) => {
  try {
    await sql.connect(dbConfig);
    const result = await sql.query(`
      SELECT 
        FORMAT(o.[DataOra], 'dd.MM.yy') AS [Data],
        d.[RagioneSociale],
        o.[TotaleOrdine],
        o.[NoteOrdine] AS [NOTE],
        s.[StatoEsteso]
      FROM 
        [dbo].[tbOrdiniProdotti] o
      INNER JOIN 
        [dbo].[tbDealers] d ON o.[idDealer] = d.[idDealer]
      INNER JOIN 
        [dbo].[tbStatiOrdiniProdotti] s ON o.[idStatoOrdineProdotto] = s.[IDStato]
      ORDER BY 
        o.[DataOra] DESC;
    `);
    return res.json(result.recordset || []);
  } catch (err) {
    console.error('[MASTERPRODOTTI][ORDINI] Errore:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});

// Attivazioni
app.get('/api/master/attivazioni', authenticateToken, onlyMaster, async (req, res) => {
  try {
    await sql.connect(dbConfig);
    const result = await sql.query(`
      SELECT 
        FORMAT(o.DataOra, 'dd.MM.yyyy') AS DataOrdine,
        o.IDOrdine,
        ofer.Titolo AS Offerta,
        d.RagioneSociale AS Dealer,
        s.StatoEsteso AS Stato
      FROM dbo.tbOrdini o
      LEFT JOIN dbo.tbOfferte ofer ON o.idOfferta = ofer.IDOfferta
      LEFT JOIN dbo.tbDealers d ON o.idDealer = d.IDDealer
      LEFT JOIN dbo.tbStatiOrdini s ON o.Stato = s.IDStato
      ORDER BY o.DataOra DESC;
    `);
    res.json(result.recordset || []);
  } catch (err) {
    console.error('[MASTER][ATTIVAZIONI] Errore:', err);
    res.status(500).json({ error: 'Errore server' });
  }
});

// Contratti Master
app.get('/api/master/contratti', authenticateToken, onlyMaster, async (req, res) => {
  console.log('[MASTER/CONTRATTI] Richiesta ricevuta da utente:', req.user?.email);
  
  let pool;
  try {
    pool = await sql.connect(dbConfig);
    
    const result = await pool.request().query(`
      SELECT  
        FORMAT(f.DataOra, 'dd.MM.yyyy') AS Data,
        d.RagioneSociale AS Dealer,
        f.CognomeCliente,
        f.MeseContratto,
        f.AnnoContratto,
        s.StatoEsteso AS Stato
      FROM 
        dbo.tbFilesStorage f
      LEFT JOIN 
        dbo.tbDealers d ON f.idDealer = d.IDDealer
      LEFT JOIN 
        dbo.tbStatiOrdiniContratti s ON f.Stato = s.IDStato
      ORDER BY 
        f.DataOra DESC
    `);
    
    console.log(`[MASTER/CONTRATTI] Trovati ${result.recordset.length} record`);
    return res.json(result.recordset || []);
    
  } catch (err) {
    console.error('[MASTER/CONTRATTI] Errore nel recupero dei contratti:', err);
    
    if (!res.headersSent) {
      return res.status(500).json({ 
        error: 'Errore nel recupero dei contratti',
        details: err.message,
        code: err.code
      });
    }
  } finally {
    if (pool) {
      try {
        await pool.close();
      } catch (closeErr) {
        console.error('[MASTER/CONTRATTI] Errore nella chiusura della connessione:', closeErr);
      }
    }
  }

// === Dettaglio ordine/attivazione per DEALER ===
app.get('/api/dealer/attivazione/:id', authenticateToken, async (req, res) => {
  const id = req.params.id;
  const dealerId = req.user.dealerId;
  try {
    await sql.connect(dbConfig);
    // Recupera ordine solo se appartiene al dealer
    const result = await new sql.Request()
      .input('id', sql.Int, id)
      .input('dealerId', sql.Int, dealerId)
      .query(`
        SELECT o.*, d.RagioneSociale AS Dealer, s.StatoEsteso, ofer.Titolo AS Offerta,
          CONVERT(varchar, o.DataOra, 104) AS DataOrdine,
          ofer.Crediti, ofer.Segmento, ofer.Tipo
        FROM dbo.tbOrdini o
        LEFT JOIN dbo.tbDealers d ON o.idDealer = d.IDDealer
        LEFT JOIN dbo.tbStatiOrdini s ON o.Stato = s.IDStato
        LEFT JOIN dbo.tbOfferte ofer ON o.idOfferta = ofer.IDOfferta
        WHERE o.IDOrdine = @id AND o.idDealer = @dealerId
      `);
    if (!result.recordset || result.recordset.length === 0) return res.status(404).json({ error: 'Ordine non trovato' });
    const ordine = result.recordset[0];
    // Documenti
    let documenti = [];
    try {
      const docs = await new sql.Request()
        .input('id', sql.Int, id)
        .query(`SELECT NomeOriginale AS nome, FileUrl AS url FROM dbo.tbDocumenti WHERE IDOrdine = @id`);
      documenti = docs.recordset || [];
    } catch(e) { documenti = []; }
    ordine.Documenti = documenti;
    // Storico cambi stato
    let storico = [];
    try {
      const storicoRes = await new sql.Request()
        .input('id', sql.Int, id)
        .query(`
          SELECT DataOra, Utente, StatoPrecedente, StatoNuovo, Nota
          FROM dbo.tbStoricoOrdini WHERE IDOrdine = @id
          ORDER BY DataOra DESC
        `);
      storico = storicoRes.recordset || [];
    } catch(e) { storico = []; }
    ordine.Storico = storico;
    // Payload da tbDatiOrdine
    let payload = {};
    try {
      const dati = await new sql.Request()
        .input('id', sql.Int, id)
        .query(`SELECT TOP 1 Payload FROM dbo.tbDatiOrdine WHERE IDOrdine = @id`);
      payload = dati.recordset[0]?.Payload ? JSON.parse(dati.recordset[0].Payload) : {};
    } catch(e) { payload = {}; }
    ordine.Payload = payload;
    // Payload intestatario
    let payloadInt = {};
    try {
      const datiInt = await new sql.Request()
        .input('id', sql.Int, id)
        .query(`SELECT TOP 1 Payload FROM dbo.tbDatiIntestario WHERE IDOrdine = @id`);
      payloadInt = datiInt.recordset[0]?.Payload ? JSON.parse(datiInt.recordset[0].Payload) : {};
    } catch(e) { payloadInt = {}; }
    ordine.PayloadIntestario = payloadInt;
    // File ordine
    let fileOrdine = [];
    try {
      const files = await new sql.Request()
        .input('id', sql.Int, id)
        .query(`SELECT * FROM dbo.tbFileOrdine WHERE IDOrdine = @id`);
      fileOrdine = files.recordset || [];
    } catch(e) { fileOrdine = []; }
    ordine.FileOrdine = fileOrdine;
    res.json(ordine);
  } catch (err) {
    console.error('[DEALER][DETTAGLIO ORDINE] Errore:', err);
    res.status(500).json({ error: 'Errore server' });
  }
});

// === Dettaglio ordine/attivazione per MASTER ===


// === Dettaglio ordine/attivazione per MASTER ===
app.get('/api/master/attivazione/:id', authenticateToken, onlyMaster, async (req, res) => {
  console.log('=== ROTTA MASTER CHIAMATA ===', req.params.id);
  try {
    const id = parseInt(req.params.id, 10);
    if (isNaN(id)) return res.status(400).json({ error: 'ID non valido' });
    await sql.connect(dbConfig);
    // Dati principali ordine + join
    const result = await new sql.Request()
      .input('id', sql.Int, id)
      .query(`
        SELECT o.*, d.RagioneSociale AS Dealer, s.StatoEsteso, ofer.Titolo AS Offerta,
          CONVERT(varchar, o.DataOra, 104) AS DataOrdine,
          ofer.Crediti, ofer.Segmento, ofer.Tipo
        FROM dbo.tbOrdini o
        LEFT JOIN dbo.tbDealers d ON o.idDealer = d.IDDealer
        LEFT JOIN dbo.tbStatiOrdini s ON o.Stato = s.IDStato
        LEFT JOIN dbo.tbOfferte ofer ON o.idOfferta = ofer.IDOfferta
        WHERE o.IDOrdine = @id
      `);
    if (!result.recordset || result.recordset.length === 0) return res.status(404).json({ error: 'Ordine non trovato' });
    const ordine = result.recordset[0];
    // Documenti
    let documenti = [];
    try {
      const docs = await new sql.Request()
        .input('id', sql.Int, id)
        .query(`SELECT NomeOriginale AS nome, FileUrl AS url FROM dbo.tbDocumenti WHERE IDOrdine = @id`);
      documenti = docs.recordset || [];
    } catch(e) { documenti = []; }
    ordine.Documenti = documenti;
    // Storico cambi stato
    let storico = [];
    try {
      const storicoRes = await new sql.Request()
        .input('id', sql.Int, id)
        .query(`
          SELECT DataOra, Utente, StatoPrecedente, StatoNuovo, Nota
          FROM dbo.tbStoricoOrdini WHERE IDOrdine = @id
          ORDER BY DataOra DESC
        `);
      storico = storicoRes.recordset || [];
    } catch(e) { storico = []; }
    ordine.Storico = storico;
    // Payload da tbDatiOrdine
    let payload = {};
    try {
      const dati = await new sql.Request()
        .input('id', sql.Int, id)
        .query(`SELECT TOP 1 Payload FROM dbo.tbDatiOrdine WHERE IDOrdine = @id`);
      payload = dati.recordset[0]?.Payload ? JSON.parse(dati.recordset[0].Payload) : {};
    } catch(e) { payload = {}; }
    ordine.Payload = payload;
    // Payload intestatario
    let payloadInt = {};
    try {
      const datiInt = await new sql.Request()
        .input('id', sql.Int, id)
        .query(`SELECT TOP 1 Payload FROM dbo.tbDatiIntestario WHERE IDOrdine = @id`);
      payloadInt = datiInt.recordset[0]?.Payload ? JSON.parse(datiInt.recordset[0].Payload) : {};
    } catch(e) { payloadInt = {}; }
    ordine.PayloadIntestario = payloadInt;
    // File ordine
    let fileOrdine = [];
    try {
      const files = await new sql.Request()
        .input('id', sql.Int, id)
        .query(`SELECT * FROM dbo.tbFileOrdine WHERE IDOrdine = @id`);
      fileOrdine = files.recordset || [];
    } catch(e) { fileOrdine = []; }
    ordine.FileOrdine = fileOrdine;
    res.json(ordine);
  } catch (err) {
    console.error('[MASTER][DETTAGLIO ORDINE] Errore:', err);
    res.status(500).json({ error: 'Errore server' });
  }
});

// === Cambio stato ordine/attivazione per MASTER ===
app.post('/api/master/attivazione/:id/stato', authenticateToken, onlyMaster, express.json(), async (req, res) => {
  const id = req.params.id;
  const { nuovoStato, nota } = req.body;
  if (![2,3,4].includes(Number(nuovoStato))) return res.status(400).json({ error: 'Stato non valido' });
  try {
    await sql.connect(dbConfig);
    // Recupera stato precedente
    const prevRes = await sql.query(`SELECT Stato FROM dbo.tbOrdini WHERE IDOrdine = @id`).input('id', sql.Int, id);
    if (!prevRes.recordset || prevRes.recordset.length === 0) return res.status(404).json({ error: 'Ordine non trovato' });
    const statoPrecedente = prevRes.recordset[0].Stato;
    // Aggiorna stato e nota
    await sql.query(`
      UPDATE dbo.tbOrdini SET Stato = @stato, NoteOrdine = @nota WHERE IDOrdine = @id
    `)
      .input('stato', sql.Int, nuovoStato)
      .input('nota', sql.NVarChar, nota || '')
      .input('id', sql.Int, id);
    // Log storico
    await sql.query(`
      INSERT INTO dbo.tbStoricoOrdini (IDOrdine, DataOra, Utente, StatoPrecedente, StatoNuovo, Nota)
      VALUES (@id, GETDATE(), @utente, @statoPrecedente, @statoNuovo, @nota)
    `)
      .input('id', sql.Int, id)
      .input('utente', sql.NVarChar, req.user.email || 'MASTER')
      .input('statoPrecedente', sql.Int, statoPrecedente)
      .input('statoNuovo', sql.Int, nuovoStato)
      .input('nota', sql.NVarChar, nota || '');
    res.json({ success: true });
  } catch (err) {
    console.error('[MASTER][CAMBIO STATO ORDINE] Errore:', err);
    res.status(500).json({ error: 'Errore server' });
  }
});

  try {
    await sql.connect(dbConfig);
    const result = await sql.query(`
      SELECT 
        FORMAT(f.DataOra, 'dd.MM.yyyy') AS Data,
        d.RagioneSociale AS Dealer,
        f.CognomeCliente,
        f.MeseContratto,
        f.AnnoContratto,
        s.StatoEsteso AS Stato
      FROM 
        dbo.tbFilesStorage f
      LEFT JOIN 
        dbo.tbDealers d ON f.idDealer = d.IDDealer
      LEFT JOIN 
        dbo.tbStatiOrdiniContratti s ON f.Stato = s.IDStato
      ORDER BY 
        f.DataOra DESC;
    `);
    res.json(result.recordset || []);
  } catch (err) {
    console.error('[MASTER][CONTRATTI] Errore:', err);
    res.status(500).json({ error: 'Errore server' });
  }
});

// 2. Confirm password reset
app.post('/api/password-reset-confirm', express.json(), async (req, res) => {
  const { email, token, newPassword } = req.body;
  if (!email || !token || !newPassword) return res.status(400).json({ error: 'Dati mancanti' });
  const entry = passwordResetTokens.get(email);
  if (!entry || entry.token !== token || entry.expires < Date.now() || entry.used) {
    return res.status(400).json({ error: 'Token non valido o scaduto' });
  }
  try {
    await sql.connect(dbConfig);
    // Hash new password (ASP.NET Identity v3)
    const hashedPw = await aspnetIdentityPw.hashPassword(newPassword);
    console.log('[RESET][DEBUG] Conferma reset per email:', email);
    console.log('[RESET][DEBUG] Nuovo hash generato:', hashedPw);
    const updateResult = await new sql.Request()
      .input('email', sql.NVarChar, email)
      .input('hash', sql.NVarChar, hashedPw)
      .query('UPDATE dbo.AspNetUsers SET PasswordHash = @hash WHERE Email = @email');
    console.log('[RESET][DEBUG] Risultato update SQL:', updateResult);
    entry.used = true;
    return res.json({ success: true });
  } catch (err) {
    console.error('[RESET] Errore conferma reset:', err);
    return res.status(500).json({ error: 'Errore server' });
  }
});

// Endpoint pubblico per ottenere la chiave pubblica Stripe
app.get('/api/stripe/public-key', (req, res) => {
  res.json({ publicKey: process.env.STRIPE_PUBLIC_KEY || '' });
});

// --- ATTENZIONE: il webhook Stripe DEVE essere la primissima route! ---
// Webhook Stripe - Nessun middleware (nemmeno connessione DB o body parser) deve precedere questa route
// Questa è l'unica implementazione del webhook Stripe
app.post('/webhook/stripe', express.raw({type: 'application/json'}), async (req, res) => {
  console.log('[STRIPE WEBHOOK] Ricevuta richiesta:', {
    headers: req.headers,
    rawBody: req.body && req.body.length ? req.body.toString('utf8') : '[vuoto]'
  });
  const stripeWebhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
  const sig = req.headers['stripe-signature'];
  let event;
  try {
    event = stripe.webhooks.constructEvent(req.body, sig, stripeWebhookSecret);
    console.log('[STRIPE WEBHOOK] Evento verificato:', event.type);
    try {
      if (event.type === 'payment_intent.succeeded') {
        const pi = event.data.object;
        const userId = pi.metadata.userId;
// --- Validazione userId (deve essere un numero valido) ---
if (!userId || isNaN(Number(userId)) || userId === 'undefined') {
  console.error('[STRIPE WEBHOOK] userId non valido nel metadata Stripe:', userId, pi.metadata);
  return res.status(400).json({ error: 'userId non valido o mancante nel metadata Stripe', userId, metadata: pi.metadata });
}
// --- Fine validazione userId ---
        const amount = pi.amount / 100;
        const payload = JSON.stringify(pi);
        let emailCliente = pi.metadata.emailCliente || '';
const orderType = pi.metadata.orderType || '';
console.log('[DEBUG][STRIPE] orderType:', orderType, 'metadata:', pi.metadata, 'emailCliente:', emailCliente);
if (!orderType) {
  console.warn('[DEBUG][STRIPE] orderType VUOTO! Metadata Stripe:', pi.metadata);
}
console.log('[DEBUG][STRIPE] emailCliente:', emailCliente);
        let carrello = [];
        let speseSpedizione = 0;
        let totaleOrdine = amount;
        let noteOrdine = '';
        let idStatoOrdineProdotto = 2; // Stato "Pagato" (modifica se necessario)

        // Prova a estrarre il carrello dal metadata o dal campo Payload
        if (pi.metadata && pi.metadata.carrello) {
          try { carrello = JSON.parse(pi.metadata.carrello); } catch(e) { carrello = []; }
        } else if (pi.metadata && pi.metadata.cart) {
          try { carrello = JSON.parse(pi.metadata.cart); } catch(e) { carrello = []; }
        } else if (pi.cart) {
          try { carrello = JSON.parse(pi.cart); } catch(e) { carrello = []; }
        }
        if (pi.metadata && pi.metadata.speseSpedizione) {
          speseSpedizione = Number(pi.metadata.speseSpedizione) || 0;
        }
        if (pi.metadata && pi.metadata.totaleOrdine) {
          totaleOrdine = Number(pi.metadata.totaleOrdine) || totaleOrdine;
        }
        // Normalizza sempre in euro
        if (totaleOrdine > 1000) {
          totaleOrdine = Math.round(totaleOrdine) / 100;
        }
        if (pi.metadata && pi.metadata.noteOrdine) {
          noteOrdine = pi.metadata.noteOrdine;
        }
        
        try {
          await connectToDatabase();
          let idOrdineProdotto = null;
          // Inserisci ordine SOLO se NON è una ricarica plafond
          if (orderType !== 'RIC') {
            const ordineResult = await new sql.Request()
              .input('idDealer', sql.Int, userId)
              .input('DataOra', sql.DateTime, DateTime.now().setZone('Europe/Rome').toFormat('yyyy-MM-dd HH:mm:ss'))
              .input('OrdineDA', sql.NVarChar, emailCliente)
              .input('SpeseSpedizione', sql.Int, speseSpedizione)
              .input('TotaleOrdine', sql.Int, totaleOrdine)
              .input('Payload', sql.NVarChar(sql.MAX), payload)
              .input('idStatoOrdineProdotto', sql.Int, idStatoOrdineProdotto)
              .input('NoteOrdine', sql.NVarChar, noteOrdine)
              .query(`
                INSERT INTO dbo.tbOrdiniProdotti
                  (idDealer, DataOra, OrdineDA, SpeseSpedizione, TotaleOrdine, Payload, idStatoOrdineProdotto, NoteOrdine, Note4Dealer, NoteInterne, OrdineDaAgente, DataStato)
                OUTPUT INSERTED.IDOrdineProdotto
                VALUES
                  (@idDealer, @DataOra, @OrdineDA, @SpeseSpedizione, @TotaleOrdine, @Payload, @idStatoOrdineProdotto, @NoteOrdine, '', '', 0, @DataOra)
              `);
            idOrdineProdotto = ordineResult.recordset[0].IDOrdineProdotto;
          }

          // Inserisci sempre in tbPaymentSessions per pagamenti con carta
          try {
            const isProdotto = orderType === 'PROD' || orderType === '';
            const sessionId = pi.id || null; // PaymentIntent ID per carta
            const paymentMethod = (pi.payment_method_types && pi.payment_method_types[0]) || 'card';
            const paymentIntentId = pi.id || null;
            const sourceType = isProdotto ? 'PROD' : 'RIC';
            const sourceId = isProdotto ? idOrdineProdotto : null;
            console.log('[DEBUG][STRIPE] emailCliente usata per RequestedByUser:', emailCliente);
const requestedByUser = emailCliente || '';
            const paymentState = pi.status === 'succeeded' ? 'paid' : pi.status;
            await new sql.Request()
              .input('SessionID', sql.NVarChar, sessionId)
              .input('idDealer', sql.Int, userId)
              .input('Date', sql.DateTime, DateTime.now().setZone('Europe/Rome').toFormat('yyyy-MM-dd HH:mm:ss'))
              .input('Amount', sql.Int, totaleOrdine)
              .input('SessionPayload', sql.NVarChar(sql.MAX), JSON.stringify(pi))
              .input('RequestedByUser', sql.NVarChar, requestedByUser)
              .input('State', sql.NVarChar, paymentState)
              .input('PaymentIntentId', sql.NVarChar, paymentIntentId)
              .input('PaymentMethod', sql.NVarChar, paymentMethod)
              .input('SourceType', sql.NVarChar, sourceType)
              .input('SourceID', sql.Int, sourceId)
              .query(`
                INSERT INTO dbo.tbPaymentSessions
                  (SessionID, idDealer, Date, Amount, SessionPayload, RequestedByUser, State, PaymentIntentId, PaymentMethod, SourceType, SourceID)
                VALUES
                  (@SessionID, @idDealer, @Date, @Amount, @SessionPayload, @RequestedByUser, @State, @PaymentIntentId, @PaymentMethod, @SourceType, @SourceID)
              `);
          } catch (err) {
            console.error('[PAYMENT SESSIONS] Errore inserimento:', err);
          }
          // Inserisci dettagli prodotti SOLO se NON è una ricarica plafond
          if (orderType !== 'RIC') {
            console.log('[DEBUG] Carrello al momento del dettaglio:', carrello);
            if (Array.isArray(carrello) && carrello.length > 0) {
              for (const prodotto of carrello) {
                const idOfferta = prodotto.id || prodotto.idOfferta || null;
                const quantita = prodotto.quantita || 1;
                let costoUnitario = prodotto.Crediti || prodotto.prezzo || 0;
                // Se arriva in centesimi (es. > 1000), converti in euro
                if (costoUnitario > 1000) {
                  costoUnitario = Math.round(costoUnitario) / 100;
                }
                let simType = prodotto.SIMTYPE || null;
                let simCount = prodotto.SIMCOUNT || 0;
                // Recupera dati da tbOfferte se mancanti o nulli
                if (!costoUnitario || !simType || !simCount) {
                  const offertaRes = await sql.query`SELECT Crediti, SIMTYPE, SIMCOUNT FROM dbo.tbOfferte WHERE IDOfferta = ${idOfferta}`;
                  const offerta = offertaRes.recordset[0];
                  if (offerta) {
                    if (!costoUnitario) costoUnitario = offerta.Crediti || 0;
                    if (!simType) simType = offerta.SIMTYPE || null;
                    if (!simCount) simCount = offerta.SIMCOUNT || 0;
                  }
                }
                console.log('[DEBUG] Inserisco dettaglio:', { idOrdineProdotto, idOfferta, quantita, costoUnitario, simType, simCount });
                try {
                  await new sql.Request()
                    .input('idOrdineProdotto', sql.Int, idOrdineProdotto)
                    .input('idOfferta', sql.Int, idOfferta)
                    .input('Quantita', sql.Int, quantita)
                    .input('CostoUnitario', sql.Int, costoUnitario)
                    .input('SIMTYPE', sql.NVarChar, simType)
                    .input('SIMCOUNT', sql.Int, simCount)
                    .query(`
                      INSERT INTO dbo.tbDettagliOrdiniProdotti
                        (idOrdineProdotto, idOfferta, Quantita, CostoUnitario, SIMTYPE, SIMCOUNT)
                      VALUES
                        (@idOrdineProdotto, @idOfferta, @Quantita, @CostoUnitario, @SIMTYPE, @SIMCOUNT)
                    `);
                  console.log('[DB] Dettaglio prodotto inserito in tbDettagliOrdiniProdotti:', prodotto);
                } catch (err) {
                  console.error('[ERRORE DETTAGLIO ORDINE]', err);
                }
              }
            } else {
              console.warn('[WARN] Carrello vuoto o non valido, nessun dettaglio inserito.');
            }
            console.log(`[STRIPE WEBHOOK] Ordine inserito: IDOrdineProdotto=${idOrdineProdotto}, Dealer=${userId}, Totale=${totaleOrdine}`);
          }

        } catch (dbErr) {
          console.error('[STRIPE WEBHOOK] Errore inserimento ordine:', dbErr);
        }

        // Se è una ricarica plafond, inserisci anche in tbTransazioni
        try {
          if (orderType === 'RIC') {
            const fonte = 'RIC';
            const descrizione = 'Ricarica plafond';
            const crediti = totaleOrdine;
            const dataOra = DateTime.now().setZone('Europe/Rome').toFormat('yyyy-MM-dd HH:mm:ss');
            let idAgenteTrans = null;
            try {
              const agenteRes = await sql.query`SELECT TOP 1 idAgente FROM dbo.tbDealers WHERE IDDealer = ${userId}`;
              if (agenteRes.recordset.length) {
                idAgenteTrans = agenteRes.recordset[0].idAgente || null;
              }
            } catch (err) {
              console.error('[TRANS] Errore recupero idAgente:', err);
            }
            let riferimentoTrans = null;
            try {
              const refRes = await sql.query`SELECT TOP 1 ID FROM dbo.tbPaymentSessions WHERE idDealer = ${userId} ORDER BY Date DESC`;
              if (refRes.recordset.length) {
                riferimentoTrans = refRes.recordset[0].ID;
              }
            } catch (err) {
              console.error('[TRANS] Errore recupero riferimento PaymentSession:', err);
            }
            // Fix: always use a valid string for Riferimento
            if (riferimentoTrans === null || riferimentoTrans === undefined) {
              riferimentoTrans = '';
            } else {
              riferimentoTrans = String(riferimentoTrans);
            }
            const payloadTrans = JSON.stringify(pi);
            const noteTrans = noteOrdine || '';
            console.log('[DEBUG][tbTransazioni] Inserimento:', {
  Descrizione: 'RICARICA PLAFOND (Paid)',
  idDealer: userId,
  Crediti: crediti,
  DataOra: dataOra,
  idAgente: idAgenteTrans,
  Fonte: fonte,
  Payload: payloadTrans,
  Note: noteTrans,
  Riferimento: riferimentoTrans
});
await new sql.Request()
              .input('Descrizione', sql.NVarChar, 'RICARICA PLAFOND (Paid)')
              .input('idDealer', sql.Int, userId)
              .input('Crediti', sql.Int, crediti)
              .input('DataOra', sql.DateTime, dataOra)
              .input('idAgente', sql.Int, idAgenteTrans)
              .input('Fonte', sql.NVarChar, fonte)
              .input('Payload', sql.NVarChar(sql.MAX), payloadTrans)
              .input('Note', sql.NVarChar, noteTrans)
              .input('Riferimento', sql.NVarChar, riferimentoTrans)
              .query(`
                INSERT INTO dbo.tbTransazioni
                  (Descrizione, idDealer, Crediti, DataOra, idAgente, Fonte, Payload, Note, Riferimento)
                VALUES
                  (@Descrizione, @idDealer, @Crediti, @DataOra, @idAgente, @Fonte, @Payload, @Note, @Riferimento)
              `);
          }
        } catch (err) {
          console.error('[TRANS] Errore inserimento ricarica plafond:', err);
        }
      }
      console.log('[STRIPE WEBHOOK] Logica business eseguita');
    } catch (logicErr) {
      console.error('[STRIPE WEBHOOK] Errore logica business:', logicErr);
      // Non rilanciare, rispondi comunque OK
    }
    res.json({ received: true });
    console.log('[STRIPE WEBHOOK] Risposta inviata 200 OK');
  } catch (err) {
    console.error('Errore verifica webhook Stripe:', err);
    res.status(400).send(`Webhook Error: ${err.message}`);
    console.log('[STRIPE WEBHOOK] Risposta inviata 400 Bad Request');
  }
});

// Middleware per il parsing del body JSON
app.use(express.json());

// Middleware per gestire la connessione al database
app.use(async (req, res, next) => {
  try {
    const isConnected = await connectToDatabase();
    if (!isConnected) {
      return res.status(503).json({ 
        error: 'Servizio non disponibile',
        message: 'Impossibile connettersi al database. Riprova più tardi.'
      });
    }
    next();
  } catch (err) {
    console.error('Errore nel middleware database:', err);
    res.status(500).json({ 
      error: 'Errore interno del server',
      details: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
});



// Endpoint per registrare richiesta ricarica plafond con bonifico
app.post('/api/ricarica-plafond-bonifico', authenticateToken, async (req, res) => {
  try {
    const { amount, userId } = req.body;
    const importo = Number(amount);
    if (![50, 100, 250, 500].includes(importo)) {
      return res.status(400).json({ error: 'Importo non valido' });
    }
    if (!userId) {
      return res.status(400).json({ error: 'userId mancante' });
    }
    // Non inserire nulla in tbTransazioni: la verifica bonifico è manuale
    res.json({ ok: true });
  } catch (err) {
    console.error('Errore in /api/ricarica-plafond-bonifico:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});

// === API per ordini con BONIFICO ===

// Endpoint per ottenere i dealer assegnati all'agente
app.get('/api/miei-dealer', authenticateToken, async (req, res) => {
  try {
    const agentEmail = req.user.email;
    if (!agentEmail) {
      return res.status(401).json({ error: 'Email agente mancante nel token' });
    }
    await connectToDatabase();
    // Recupera il nome dell'agente
    const resultAgent = await new sql.Request()
      .input('email', sql.NVarChar, agentEmail)
      .query('SELECT Nome, IdAgente FROM dbo.tbAgenti WHERE RecapitoEmail = @email');
    if (!resultAgent.recordset || resultAgent.recordset.length === 0) {
      return res.status(404).json({ error: 'Agente non trovato' });
    }
    const { Nome: nomeAgente, IdAgente } = resultAgent.recordset[0];
    // Recupera i dealer assegnati con ID, email e cell
    const resultDealers = await new sql.Request()
      .input('nomeAgente', sql.NVarChar, nomeAgente)
      .query('SELECT IDDealer, RagioneSociale, RecapitoEmail, RecapitoCell FROM dbo.tbDealers WHERE AGENTE = @nomeAgente');
    const dealers = resultDealers.recordset.map(d => ({
      id: d.IDDealer,
      nome: d.RagioneSociale,
      email: d.RecapitoEmail,
      telefono: d.RecapitoCell || ''
    }));
    return res.json({ dealers, idAgente: IdAgente });
  } catch (err) {
    console.error('Errore in /api/miei-dealer:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});

// Endpoint per l'invio ordine da agente a dealer
app.post('/api/ordine-agente', authenticateToken, express.json(), async (req, res) => {
  try {
    const { carrello, idDealer, noteOrdine, idAgente } = req.body;
    
    if (!Array.isArray(carrello) || carrello.length === 0) {
      return res.status(400).json({ error: 'Carrello vuoto' });
    }
    
    if (!idDealer) {
      return res.status(400).json({ error: 'Dealer non specificato' });
    }
    
    await connectToDatabase();
    
    // Calcola il totale dell'ordine
    const totaleOrdine = carrello.reduce((tot, item) => {
      const prezzo = item.Crediti || item.prezzo || 0;
      const quantita = item.quantita || 1;
      return tot + (prezzo * quantita);
    }, 0);
    
    // Inserisci l'ordine
    const payload = JSON.stringify(carrello);
    const dataOra = DateTime.now().setZone('Europe/Rome').toFormat('yyyy-MM-dd HH:mm:ss');
    
    // Inizia la transazione
    const transaction = new sql.Transaction();
    await transaction.begin();
    
    try {
      const request = new sql.Request(transaction);
      
      // Inserisci l'ordine principale
      const ordineResult = await request
        .input('idDealer', sql.Int, idDealer)
        .input('DataOra', sql.DateTime, dataOra)
        .input('OrdineDA', sql.NVarChar, `Agente ID: ${idAgente}`)
        .input('SpeseSpedizione', sql.Int, 0)
        .input('TotaleOrdine', sql.Int, totaleOrdine)
        .input('Payload', sql.NVarChar(sql.MAX), payload)
        .input('idStatoOrdineProdotto', sql.Int, 10) // DA_ELABORARE_AGENTE per agenti
        .input('NoteOrdine', sql.NVarChar, noteOrdine || '')
        .input('OrdineDaAgente', sql.Int, 1) // Flag ordine da agente
        .query(`
          INSERT INTO dbo.tbOrdiniProdotti
            (idDealer, DataOra, OrdineDA, SpeseSpedizione, TotaleOrdine, Payload, 
             idStatoOrdineProdotto, NoteOrdine, Note4Dealer, NoteInterne, OrdineDaAgente, DataStato)
          OUTPUT INSERTED.IDOrdineProdotto
          VALUES
            (@idDealer, @DataOra, @OrdineDA, @SpeseSpedizione, @TotaleOrdine, @Payload, 
             @idStatoOrdineProdotto, @NoteOrdine, '', '', @OrdineDaAgente, @DataOra)
        `);
      
      const idOrdineProdotto = ordineResult.recordset[0].IDOrdineProdotto;
      
      // Inserisci i dettagli dell'ordine
      try {
        for (const prodotto of carrello) {
          const idOfferta = prodotto.id || prodotto.idOfferta || null;
          const quantita = prodotto.quantita || 1;
          const costoUnitario = prodotto.Crediti || prodotto.prezzo || 0;
          const simType = prodotto.SIMTYPE || null;
          const simCount = prodotto.SIMCOUNT || 0;
          
          await (new sql.Request(transaction))
            .input('idOrdineProdotto', sql.Int, idOrdineProdotto)
            .input('idOfferta', sql.Int, idOfferta)
            .input('Quantita', sql.Int, quantita)
            .input('CostoUnitario', sql.Int, costoUnitario)
            .input('SIMTYPE', sql.NVarChar, simType)
            .input('SIMCOUNT', sql.Int, simCount)
            .query(`
              INSERT INTO dbo.tbDettagliOrdiniProdotti
                (idOrdineProdotto, idOfferta, Quantita, CostoUnitario, SIMTYPE, SIMCOUNT)
              VALUES
                (@idOrdineProdotto, @idOfferta, @Quantita, @CostoUnitario, @SIMTYPE, @SIMCOUNT)
            `);
        }
        
        // Commit della transazione
        await transaction.commit();

        // --- NOTIFICHE DOPO CREAZIONE ORDINE ---
        try {
          // Recupera dati dealer
          const dealerRes = await new sql.Request()
            .input('idDealer', sql.Int, idDealer)
            .query('SELECT RagioneSociale, RecapitoEmail, RecapitoCell FROM dbo.tbDealers WHERE IDDealer = @idDealer');
          const dealerData = dealerRes.recordset[0];

          // 1. EMAIL
          try {
            const nodemailer = require('nodemailer');
            const transporter = nodemailer.createTransport({
              host: 'mail.kimweb.agency',
              port: 465,
              secure: true,
              auth: {
                user: 'kimstation.noreply@kimweb.agency',
                pass: process.env.EMAIL_PASSWORD // la password resta da env
              }
            });
            const fs = require('fs');
let html = fs.readFileSync(path.join(__dirname, 'emailTemplates/orderAgent.html'), 'utf8');
const righeProdotti = carrello.map(p =>
  `<tr>
    <td>${p.nome || p.Nome || p.titolo || p.Titolo || p.descrizione || 'Prodotto'}</td>
    <td align="center">${p.quantita || 1}</td>
    <td align="right">€${((p.Crediti || p.prezzo || 0) / 100).toFixed(2)}</td>
    <td align="right">€${(((p.Crediti || p.prezzo || 0) * (p.quantita || 1)) / 100).toFixed(2)}</td>
  </tr>`
).join('');
html = html
  .replace('{{dealerName}}', dealerData.RagioneSociale)
  .replace('{{totale}}', (totaleOrdine / 100).toFixed(2))
  .replace('{{note}}', noteOrdine || '-')
  .replace('{{idOrdineProdotto}}', idOrdineProdotto)
  .replace('{{righeProdotti}}', righeProdotti)
  .replace('{{spedizione}}', (carrello[0] && carrello[0].spedizione) || 'Non specificata');
const mailOptions = {
  from: 'kimstation.noreply@kimweb.agency',
  to: 'comunicazioni@kimweb.it',
  cc: undefined,
  subject: `Nuovo ordine da agente #${idOrdineProdotto}`,
  html,
  attachments: [{
    filename: 'logo.png',
    path: '/home/ubuntu/staging3.kimweb.agency/Logo/logo.png',
    cid: 'logo@kimweb.agency'
  }]
};
            console.log('[NOTIFICA][MAIL][INVIO] Dest:', mailOptions.to, '| Subject:', mailOptions.subject);
            const mailInfo = await transporter.sendMail(mailOptions);
            console.log('[NOTIFICA][MAIL][SUCCESS] Risposta nodemailer:', mailInfo);
          } catch (mailErr) {
            console.error('[NOTIFICA][MAIL] Errore invio mail:', mailErr);
          }

          // 2. WHATSAPP
          try {
            if (dealerData.RecapitoCell) {
              const phoneRaw = dealerData.RecapitoCell || '';
              const phoneClean = phoneRaw.replace(/\D/g, '');
              const phoneInt = phoneClean.startsWith('39') ? phoneClean : '39' + phoneClean;
              const whatsappPayload = {
                user_id: phoneInt,
                text: `Hai un nuovo ordine da pagare!\nAccedi alla tua area riservata per i dettagli.\nOrdine #${idOrdineProdotto} - Totale: €${totaleOrdine / 100}`
              };
              console.log('[NOTIFICA][WHATSAPP][INVIO] user_id:', whatsappPayload.user_id, '| Text:', whatsappPayload.text);
              const waResp = await axios.post('https://bot.kimweb.agency/send-whatsapp', whatsappPayload);
              if (waResp.data && waResp.data.status === 'success') {
                console.log('[NOTIFICA][WHATSAPP][SUCCESS] Risposta bot:', waResp.data);
              } else {
                console.error('[NOTIFICA][WHATSAPP][ERRORE] Risposta bot:', waResp.data);
              }
            }
          } catch (waErr) {
            console.error('[NOTIFICA][WHATSAPP] Errore invio WhatsApp:', waErr);
          }
        } catch (notifErr) {
          console.error('[NOTIFICA] Errore generale:', notifErr);
        }

        res.status(201).json({
          success: true,
          message: 'Ordine creato con successo',
          orderId: idOrdineProdotto
        });
        
      } catch (err) {
        // Rollback in caso di errore
        await transaction.rollback();
        console.error('Errore durante la creazione dell\'ordine:', err);
        res.status(500).json({
          success: false,
          message: 'Errore durante la creazione dell\'ordine',
          error: err.message
        });
      }
    } catch (err) {
      console.error('Errore nella gestione della transazione:', err);
      res.status(500).json({
        success: false,
        message: 'Errore nella gestione della transazione',
        error: err.message
      });
    }
  } catch (err) {
    console.error('Errore generale nell\'endpoint /api/ordine-agente:', err);
    res.status(500).json({
      success: false,
      message: 'Errore interno del server',
      error: err.message
    });
  }
});


// Configurazione avanzata per la connessione al database
// Le opzioni di connessione sono state consolidate qui
// Le variabili d'ambiente hanno la precedenza sui valori predefiniti

// Avvia il server Express sempre, senza attendere la connessione al database
const PORT = process.env.PORT || 3002;
app.listen(PORT, () => {
  console.log(`Server Express in esecuzione su http://localhost:${PORT}`);
});


// Endpoint pubblico per ottenere la chiave pubblica Stripe (deve essere prima di qualsiasi middleware di autenticazione!)
app.get('/api/stripe/public-key', (req, res) => {
  res.json({ publicKey: process.env.STRIPE_PUBLIC_KEY || '' });
});

// Endpoint per la ricarica plafond (solo carta di credito)
app.post('/api/ricarica-plafond', authenticateToken, async (req, res) => {
  try {
    const { amount, emailCliente } = req.body;
    const userId = req.user.id || req.user.userId; // Support both id and userId from JWT
    // DEBUG: log which field is used
    console.log('[DEBUG][ricarica-plafond] req.user:', req.user, 'Estratto userId:', userId);
console.log('[DEBUG][ricarica-plafond] req.user:', req.user, 'Estratto userId:', userId);

    // Logica unica per CARTA DI CREDITO
    console.log(`[DEBUG] Creazione PaymentIntent per ricarica plafond: Ricevuto body=${JSON.stringify(req.body)}`);

    const paymentIntent = await stripe.paymentIntents.create({
      amount: Number(amount) * 100, // euro -> centesimi
      currency: 'eur',
      payment_method_types: ['card'],
      metadata: { 
        userId: String(userId), 
        orderType: 'RIC', 
        emailCliente: emailCliente 
      }
    });

    res.json({ client_secret: paymentIntent.client_secret });

  } catch (error) {
    console.error('Errore durante la creazione del payment intent per ricarica:', error);
    res.status(500).json({ error: 'Errore interno del server durante la creazione del pagamento.' });
  }
});

// Endpoint Stripe PaymentIntent per pagamenti prodotti (importo libero)
app.post('/api/stripe/create-product-payment-intent', express.json(), async (req, res) => {
  try {
    const { amount, userId, carrello, emailCliente, speseSpedizione, noteOrdine, metadata = {} } = req.body;
    if (!amount || isNaN(Number(amount))) {
      return res.status(400).json({ error: 'Importo non valido' });
    }
    if (!userId) {
      return res.status(400).json({ error: 'userId mancante' });
    }
    // You can add further validation for carrello, emailCliente, etc. if needed
    // Prepara un carrello "safe" solo con id e quantità
    const safeCarrello = carrello && Array.isArray(carrello)
      ? JSON.stringify(carrello.map(({ id, quantita }) => ({ id, quantita })))
      : '';
    // Costruisci un metadata solo con stringhe e campi semplici
    const safeMetadata = {
      userId: String(userId),
      emailCliente: String(emailCliente || ''),
      carrello: safeCarrello,
      speseSpedizione: typeof speseSpedizione !== 'undefined' ? String(speseSpedizione) : '0',
      noteOrdine: String(noteOrdine || ''),
      ...Object.fromEntries(
        Object.entries(metadata || {}).filter(([k, v]) => typeof v === 'string' || typeof v === 'number')
      )
    };
    safeMetadata.carrello = safeCarrello;

    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(Number(amount) * 100),
      currency: 'eur',
      payment_method_types: ['card'],
      metadata: safeMetadata
    });
    res.json({ client_secret: paymentIntent.client_secret });
  } catch (err) {
    console.error('Errore creazione PaymentIntent prodotto:', err);
    res.status(500).json({ error: 'Errore server Stripe' });
  }
});

// Endpoint Stripe PaymentIntent per pagamenti carrello ecommerce (importo libero)
app.post('/api/stripe/cart-payment-intent', express.json(), async (req, res) => {
  try {
    const { amount, userId, orderToken } = req.body;
    if (!amount || isNaN(Number(amount))) {
      return res.status(400).json({ error: 'Importo non valido' });
    }
    if (!userId) {
      return res.status(400).json({ error: 'userId mancante' });
    }
    const paymentIntent = await stripe.paymentIntents.create({
      amount: Math.round(Number(amount) * 100),
      currency: 'eur',
      payment_method_types: ['card'],
      metadata: {
        userId: String(userId),
        orderToken
      }
    });
    res.json({ client_secret: paymentIntent.client_secret });
  } catch (err) {
    console.error('Errore creazione PaymentIntent carrello:', err);
    res.status(500).json({ error: 'Errore server Stripe' });
  }
});

// Endpoint per salvataggio pre-ordine temporaneo
app.post('/api/order/pre-save', express.json(), async (req, res) => {
  try {
    const { orderToken, userId, emailCliente, carrello } = req.body;
    if (!orderToken || !userId || !carrello) {
      return res.status(400).json({ error: 'orderToken, userId, carrello sono obbligatori' });
    }
    await sql.connect(dbConfig);
    await new sql.Request()
      .input('OrderToken', sql.NVarChar(64), orderToken)
      .input('UserId', sql.Int, userId)
      .input('EmailCliente', sql.NVarChar(255), emailCliente || '')
      .input('Carrello', sql.NVarChar(sql.MAX), carrello)
      .query(`INSERT INTO dbo.tbOrdiniTemp (OrderToken, UserId, EmailCliente, Carrello) VALUES (@OrderToken, @UserId, @EmailCliente, @Carrello)`);
    res.json({ ok: true });
  } catch (err) {
    console.error('[PRE-SAVE ERROR]', err);
    res.status(500).json({ error: 'Errore nel salvataggio pre-ordine' });
  }
});

// Endpoint richiesta bonifico (solo log)
app.post('/api/bonifico-request', express.json(), (req, res) => {
  const { amount, userId } = req.body;
  console.log('Richiesta bonifico:', { amount, userId });
  res.json({ ok: true });
});



// Endpoint rimosso: era un duplicato del webhook Stripe (vedi riga 131)

// Endpoint di test semplice
app.get('/api/test', (req, res) => {
  res.json({ status: 'ok', message: 'Il server è in esecuzione' });
});

// Endpoint per la dashboard: ultime 5 attivazioni
app.use('/api/ultime-attivazioni', (req, res, next) => {
  console.log(`[PRE-AUTH LOG] Richiesta ricevuta per /api/ultime-attivazioni. Header Auth: ${req.headers['authorization']}`);
  next();
});
app.get('/api/ultime-attivazioni', authenticateToken, async (req, res) => {
  console.log('[DEBUG][GET /api/ultime-attivazioni] URL:', req.originalUrl, '| Query:', req.query, '| Headers:', req.headers);
  try {
    // Estrai il token JWT dall'header Authorization
    // Dati utente già disponibili grazie al middleware authenticateToken
    const dealerId = req.user.dealerId;
    if (!dealerId) {
      return res.status(401).json({ error: 'ID dealer non valido nel token' });
    }
    await sql.connect(dbConfig);
    const request = new sql.Request();
    request.input('idDealer', sql.Int, dealerId);
    // Logica filtro operatore per la dashboard
    let query;
    const operatore = req.query.operatore;
    if (operatore === 'SKY') {
      query = `
        SELECT TOP 5
          CONVERT(VARCHAR(10), o.DataOra, 120) AS Data,
          offr.Titolo AS Titolo,
          offr.Tipo AS Tipo,
          offr.Segmento AS Segmento,
          so.StatoEsteso AS Stato
        FROM dbo.tbOrdini o
        LEFT JOIN dbo.tbStatiOrdini so ON o.Stato = so.IDStato
        LEFT JOIN dbo.TbOfferte offr ON o.idOfferta = offr.IDOfferta
        WHERE o.idDealer = @idDealer
          AND offr.idOperatore IN (3, 8, 12, 14)
        ORDER BY o.DataOra DESC`;
    } else if (operatore === 'ILIAD') {
      query = `
        SELECT TOP 5
          CONVERT(VARCHAR(10), o.DataOra, 120) AS Data,
          offr.Titolo AS Titolo,
          offr.Tipo AS Tipo,
          offr.Segmento AS Segmento,
          so.StatoEsteso AS Stato
        FROM dbo.tbOrdini o
        LEFT JOIN dbo.tbStatiOrdini so ON o.Stato = so.IDStato
        LEFT JOIN dbo.TbOfferte offr ON o.idOfferta = offr.IDOfferta
        WHERE o.idDealer = @idDealer
          AND offr.idOperatore IN (5)
        ORDER BY o.DataOra DESC`;
    } else if (operatore === 'KENA MOBILE') {
      query = `
        SELECT TOP 5
          CONVERT(VARCHAR(10), o.DataOra, 120) AS Data,
          offr.Titolo AS Titolo,
          offr.Tipo AS Tipo,
          offr.Segmento AS Segmento,
          so.StatoEsteso AS Stato
        FROM dbo.tbOrdini o
        LEFT JOIN dbo.tbStatiOrdini so ON o.Stato = so.IDStato
        LEFT JOIN dbo.TbOfferte offr ON o.idOfferta = offr.IDOfferta
        WHERE o.idDealer = @idDealer
          AND offr.idOperatore IN (6)
        ORDER BY o.DataOra DESC`;
    } else if (operatore === 'WEEDOO') {
      query = `
        SELECT TOP 5
          CONVERT(VARCHAR(10), o.DataOra, 120) AS Data,
          offr.Titolo AS Titolo,
          offr.Tipo AS Tipo,
          offr.Segmento AS Segmento,
          so.StatoEsteso AS Stato
        FROM dbo.tbOrdini o
        LEFT JOIN dbo.tbStatiOrdini so ON o.Stato = so.IDStato
        LEFT JOIN dbo.TbOfferte offr ON o.idOfferta = offr.IDOfferta
        WHERE o.idDealer = @idDealer
          AND offr.idOperatore IN (13)
        ORDER BY o.DataOra DESC`;
    } else if (operatore === '1MOBILE') {
      query = `
        SELECT TOP 5
          CONVERT(VARCHAR(10), o.DataOra, 120) AS Data,
          offr.Titolo AS Titolo,
          offr.Tipo AS Tipo,
          offr.Segmento AS Segmento,
          so.StatoEsteso AS Stato
        FROM dbo.tbOrdini o
        LEFT JOIN dbo.tbStatiOrdini so ON o.Stato = so.IDStato
        LEFT JOIN dbo.TbOfferte offr ON o.idOfferta = offr.IDOfferta
        WHERE o.idDealer = @idDealer
          AND offr.idOperatore IN (7)
        ORDER BY o.DataOra DESC`;
    } else if (operatore === 'FASTWEB') {
      query = `
        WITH CTE_OrdiniUnici AS (
            SELECT
                CONVERT(VARCHAR(10), i.[Data Inserimento Ordine], 105) AS Data,
                i.Valore AS Valore,
                i.[FiscalCodeOrPiva] AS CodiceFiscale,
                i.Segmento AS Segmento,
                i.[Codice Ordine] AS CodiceOrdine,
                i.[Stato dell'Ordine OM] AS StatoOrdine,
                i.Contributo,
                i.[Tipo Ordine] AS TipoOrdine,
                i.Canone,
                ROW_NUMBER() OVER (PARTITION BY i.[Codice Ordine] ORDER BY i.[Data Inserimento Ordine] DESC) AS rn
            FROM dbo.InseritoFW i
            INNER JOIN dbo.tbDealers d 
                ON i.[Codice Comsy Tecnico Attuale] = d.COMSY1
                OR i.[Codice Comsy Tecnico Attuale] = d.COMSY2
            WHERE d.idDealer = @idDealer
        )
        SELECT TOP 5
            Data,
            LEFT(Valore, 30) AS Titolo,
            TipoOrdine AS Tipo,
            Segmento,
            StatoOrdine AS Stato,
            CodiceOrdine,
            Contributo,
            TipoOrdine,
            Canone
        FROM CTE_OrdiniUnici
        WHERE rn = 1
        ORDER BY Data DESC`;
    } else if (operatore === 'FASTWEB ENERGIA') {
      query = `
        WITH CTE_ContrattiUnici AS (
            SELECT
                CONVERT(VARCHAR(10), f.[DataBatch], 105) AS Data,
                f.[Codice Contratto] AS CodiceContratto,
                f.[Codice POD] AS CodicePOD,
                f.[Tipo Cliente] AS TipoCliente,
                f.Segmento,
                f.[Stato Contratto] AS StatoContratto,
                f.[Stato Fornitura Luce] AS StatoFornitura,
                f.[Tipo Vendita] AS TipoVendita,
                f.[Tipo Passaggio] AS TipoPassaggio,
                f.[Nome Offerta Vendita] AS NomeOfferta,
                ROW_NUMBER() OVER (PARTITION BY f.[Codice Contratto] ORDER BY f.[DataBatch] DESC) AS rn
            FROM dbo.FWEnergiaimporter f
            INNER JOIN dbo.tbDealers d 
                ON f.[Codice Comsy/Order Owner (Report!DBSELLER)] = d.COMSY1
                OR f.[Codice Comsy/Order Owner (Report!DBSELLER)] = d.COMSY2
            WHERE d.idDealer = @idDealer
        )
        SELECT TOP 5
            Data,
            o.Titolo,
            CodicePOD AS Tipo,
            Segmento,
            StatoContratto AS Stato,
            StatoFornitura,
            TipoCliente,
            TipoVendita,
            TipoPassaggio,
            f.[Nome Offerta Vendita] AS NomeOfferta
        FROM CTE_ContrattiUnici
        WHERE rn = 1
        ORDER BY Data DESC`;
    } else if (operatore) {
      query = `
        SELECT TOP 5
          CONVERT(VARCHAR(10), o.DataOra, 120) AS Data,
          offr.Titolo AS Titolo,
          offr.Tipo AS Tipo,
          offr.Segmento AS Segmento,
          so.StatoEsteso AS Stato
        FROM dbo.tbOrdini o
        LEFT JOIN dbo.tbStatiOrdini so ON o.Stato = so.IDStato
        LEFT JOIN dbo.TbOfferte offr ON o.idOfferta = offr.IDOfferta
        WHERE o.idDealer = @idDealer
          AND offr.idOperatore = (SELECT TOP 1 IDOperatore FROM dbo.tbOperatori2 WHERE UPPER(Nome) = UPPER(@operatore))
        ORDER BY o.DataOra DESC`;
      request.input('operatore', sql.NVarChar, operatore);
    } else {
      return res.status(400).json({ error: "Parametro 'operatore' obbligatorio" });
    }
    const result = await request.query(query);
    res.json({ attivazioni: result.recordset || [] });
  } catch (err) {
    console.error('Errore in /api/ultime-attivazioni:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});

// Endpoint per ottenere le statistiche delle attivazioni per l'agente
app.get('/api/statistiche-agente', authenticateToken, async (req, res) => {
  console.log('=== CHIAMATA A /api/statistiche-agente ===');
  console.log('Utente autenticato:', {
    id: req.user.id,
    email: req.user.email,
    role: req.user.role,
    agenteNome: req.user.agenteNome
  });
  
  try {
    // Verifica che l'utente sia un agente (controlla entrambe le varianti di maiuscole)
    const userRole = req.user.role || (req.user.ruoli && req.user.ruoli[0]);
    const isAgente = userRole && (userRole.toUpperCase() === 'AGENTE' || userRole === 'Agente');
    
    if (!isAgente) {
      console.log('Accesso negato: ruolo non valido', { 
        userRole,
        ruoli: req.user.ruoli,
        user: req.user 
      });
      return res.status(403).json({ 
        error: 'Accesso consentito solo agli agenti',
        requiredRole: 'AGENTE',
        userRole: userRole,
        userRoles: req.user.ruoli
      });
    }

    // Ottieni il nome dell'agente dal token
    const agenteNome = req.user.agenteNome;
    if (!agenteNome) {
      return res.status(400).json({ error: 'Nome agente non specificato nel token' });
    }

    // Ottieni i parametri di filtraggio
    const { anno, mese } = req.query;
    
    // Costruisci la query SQL
    let query = `
    DECLARE @agenteParam NVARCHAR(100) = @agenteNome;
    
    WITH DealerAgente AS (
        SELECT idDealer, COMSY1, COMSY2
        FROM dbo.tbDealers
        WHERE AGENTE = @agenteParam
    ),
    
    -- FASTWEB
    MaxBatchFW AS (
        SELECT 
            YEAR([Batch]) AS Anno, MONTH([Batch]) AS Mese, MAX([Batch]) AS MaxBatch
        FROM dbo.InseritoFW i
        INNER JOIN DealerAgente d ON i.[Codice Comsy Tecnico Attuale] IN (d.COMSY1, d.COMSY2)
        GROUP BY YEAR([Batch]), MONTH([Batch])
    ),
    Fastweb AS (
        SELECT 
            'FASTWEB' AS Operatore, 
            YEAR(i.[Batch]) AS Anno, 
            MONTH(i.[Batch]) AS Mese,
            i.[Codice Ordine],
            ROW_NUMBER() OVER (PARTITION BY i.[Codice Ordine], YEAR(i.Batch), MONTH(i.Batch) ORDER BY i.[Data Inserimento Ordine] DESC) AS rn
        FROM dbo.InseritoFW i
        INNER JOIN DealerAgente d ON i.[Codice Comsy Tecnico Attuale] IN (d.COMSY1, d.COMSY2)
        INNER JOIN MaxBatchFW mb ON YEAR(i.Batch) = mb.Anno AND MONTH(i.Batch) = mb.Mese AND i.Batch = mb.MaxBatch
    ),

    -- FASTWEB ENERGIA
    MaxBatchFWE AS (
        SELECT 
            YEAR([Batch]) AS Anno, MONTH([Batch]) AS Mese, MAX([Batch]) AS MaxBatch
        FROM dbo.FWEnergiaimporter f
        INNER JOIN DealerAgente d ON f.[Codice Comsy/Order Owner (Report!DBSELLER)] IN (d.COMSY1, d.COMSY2)
        GROUP BY YEAR([Batch]), MONTH([Batch])
    ),
    FastwebEnergia AS (
        SELECT 
            'FASTWEB ENERGIA' AS Operatore, 
            YEAR(f.[Batch]) AS Anno, 
            MONTH(f.[Batch]) AS Mese,
            f.[Codice Contratto],
            ROW_NUMBER() OVER (PARTITION BY f.[Codice Contratto], YEAR(f.Batch), MONTH(f.Batch) ORDER BY f.Batch DESC) AS rn
        FROM dbo.FWEnergiaimporter f
        INNER JOIN DealerAgente d ON f.[Codice Comsy/Order Owner (Report!DBSELLER)] IN (d.COMSY1, d.COMSY2)
        INNER JOIN MaxBatchFWE mb ON YEAR(f.Batch) = mb.Anno AND MONTH(f.Batch) = mb.Mese AND f.Batch = mb.MaxBatch
    ),

    -- SKY & WEEDOO
    SkyWeedoo AS (
        SELECT 
            CASE 
                WHEN offr.idOperatore IN (3, 8, 12, 14) THEN 'SKY'
                WHEN offr.idOperatore = 13 THEN 'WEEDOO'
            END AS Operatore,
            YEAR(o.DataOra) AS Anno,
            MONTH(o.DataOra) AS Mese,
            o.idOrdine
        FROM dbo.tbOrdini o
        LEFT JOIN dbo.TbOfferte offr ON o.idOfferta = offr.IDOfferta
        WHERE o.idDealer IN (SELECT idDealer FROM DealerAgente)
          AND offr.idOperatore IN (3, 8, 12, 13, 14)
    )

    -- OUTPUT FINALE CONTEZZA
    SELECT 
        Operatore, 
        Anno, 
        Mese, 
        FORMAT(DATEFROMPARTS(Anno, Mese, 1), 'yyyy-MM-dd') as Data,
        COUNT(*) AS NumeroAttivazioni
    FROM (
        SELECT Operatore, Anno, Mese FROM Fastweb WHERE rn = 1
        UNION ALL
        SELECT Operatore, Anno, Mese FROM FastwebEnergia WHERE rn = 1
        UNION ALL
        SELECT Operatore, Anno, Mese FROM SkyWeedoo
    ) AS Tutte
    WHERE 1=1
    `;

    // Aggiungi filtri in base ai parametri
    if (anno) {
      query += ' AND Anno = @anno';
    }
    
    if (mese) {
      query += ' AND Mese = @mese';
    }
    
    // Raggruppa e ordina
    query += '\n    GROUP BY Operatore, Anno, Mese, FORMAT(DATEFROMPARTS(Anno, Mese, 1), \'yyyy-MM-dd\')\n    ORDER BY Anno, Mese, Operatore';
    
    console.log('Esecuzione query con filtri:', { agenteNome, anno, mese });
    
    console.log('Query SQL eseguita:', query);
    
    const pool = await sql.connect(dbConfig);
    const request = pool.request();
    
    // Aggiungi i parametri
    request.input('agenteNome', sql.NVarChar, agenteNome);
    if (anno) request.input('anno', sql.Int, parseInt(anno, 10));
    if (mese) request.input('mese', sql.Int, parseInt(mese, 10));
    
    console.log('=== PARAMETRI QUERY ===');
    console.log('agenteNome:', agenteNome);
    console.log('anno:', anno);
    console.log('mese:', mese);
    console.log('Query SQL:', query);
    
      console.log('Esecuzione query...');
      const result = await request.query(query);
      console.log('Query eseguita con successo');
      console.log('Numero di record restituiti:', result.recordset.length);
      
      if (result.recordset.length > 0) {
        console.log('Primi 5 record:', result.recordset.slice(0, 5));
        
        const datiPerGrafico = [];
        const datiPerData = {};
        
        // Prima passata: crea un oggetto con tutte le date univoche
        const dateUniche = [...new Set(result.recordset.map(r => r.Data || `${r.Anno}-${String(r.Mese).padStart(2, '0')}-01`))];
        
        // Inizializza un oggetto per ogni data con tutti gli operatori a 0
        dateUniche.forEach(data => {
          datiPerData[data] = {
            data: data,
            FASTWEB: 0,
            'FASTWEB ENERGIA': 0,
            SKY: 0,
            WEEDOO: 0
          };
        });
        
        // Seconda passata: popola i conteggi
        result.recordset.forEach(row => {
          const dataKey = row.Data || `${row.Anno}-${String(row.Mese).padStart(2, '0')}-01`;
          const operatore = row.Operatore;
          const conteggio = parseInt(row.NumeroAttivazioni, 10) || 0;
          
          if (datiPerData[dataKey] && operatore) {
            datiPerData[dataKey][operatore] = conteggio;
          }
        });
        
        // Converti l'oggetto in array e ordina per data
        const datiOrdinati = Object.values(datiPerData).sort((a, b) => 
          new Date(a.data) - new Date(b.data)
        );
        
        console.log('Dati formattati per il grafico:', datiOrdinati);
        
        // Invia i dati come array di oggetti
        res.json(datiOrdinati);
      } else {
        console.log('Nessun dato trovato per i criteri specificati');
        return res.json([]);
      }
    } catch (err) {
      console.error('Errore in /api/statistiche-agente:', err);
      console.error('Stack trace:', err.stack);
      return res.status(500).json({ 
        error: 'Errore server', 
        message: err.message,
        stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
      });
    }
});

// Endpoint debug: recupera l'ultimo payment_intent da Stripe e il relativo payload dal DB
app.get('/api/stripe/ultimo-payload', authenticateToken, async (req, res) => {
  try {
    try {
      const transactions = await stripe.balanceTransactions.list({ limit: 10 });
      // Trova la prima transazione di tipo 'charge'
      const lastCharge = transactions.data.find(tx => tx.type === 'charge');
      if (!lastCharge) return res.status(404).json({ error: 'Nessuna transazione di tipo charge trovata' });

      let paymentIntentId = lastCharge.payment_intent;
      // Se non c'è direttamente, recupera la charge e prendi il payment_intent
      if (!paymentIntentId && lastCharge.source && lastCharge.source.startsWith('ch_')) {
        const charge = await stripe.charges.retrieve(lastCharge.source);
        paymentIntentId = charge.payment_intent;
      }
      if (!paymentIntentId) return res.status(404).json({ error: 'Payment intent non trovato' });

      // Recupera il payload da Stripe
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);

      // Recupera il payload dal DB
      await sql.connect(dbConfig);
      const dbRes = await sql.query`SELECT TOP 1 * FROM dbo.tbTransazioni WHERE Payload LIKE '%${paymentIntentId}%' ORDER BY idTransazione DESC`;
      const dbPayload = dbRes.recordset.length > 0 ? dbRes.recordset[0].Payload : null;

      res.json({
        payment_intent_id: paymentIntentId,
        stripe_payload: paymentIntent,
        db_payload: dbPayload
      });
    } catch (err) {
      // Debug per errori Stripe
      if (err && err.type === 'StripeAuthenticationError') {
        console.error('[STRIPE][AUTH] Errore autenticazione Stripe:', err.message);
        return res.status(500).json({ error: 'Errore autenticazione Stripe: controlla la chiave e l’ambiente', details: err.message });
      }
      res.status(500).json({ error: err.message });
    }
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Endpoint movimenti Stripe
app.get('/api/stripe/movimenti', authenticateToken, async (req, res) => {
  try {
    // Recupera le ultime 20 transazioni dal conto Stripe
    const transactions = await stripe.balanceTransactions.list({ limit: 1000 });
console.log('[DEBUG][MOVIMENTI] BalanceTransaction IDs:', transactions.data.map(tx => tx.id));
    const sql = require('mssql');
    console.log('[DEBUG][DB] dbConfig usata:', dbConfig);
    await sql.connect(dbConfig);
    const result = [];
    for (const tx of transactions.data) {
      console.log('[DEBUG][MOVIMENTI] tx:', tx);
      console.log('[DEBUG][MOVIMENTI][MATCH] tx.id:', tx.id, '| tx.source:', tx.source, '| tx.payment_intent:', tx.payment_intent);
      let chargePaymentIntent = undefined;
      let dealer = '';
      let descrizione = '';
      // Default tipo
      let tipo = tx.type === 'charge' ? 'INCASSO' : (tx.type === 'payout' ? 'EROGAZIONE' : tx.type.toUpperCase());
      // Default descrizione
      if (tx.type === 'payout') {
        descrizione = 'PAGAMENTO SU VS CONTO';
      } else if (tx.type === 'charge') {
        let transRes;
        console.log('[DEBUG][MOVIMENTI] tx.id:', tx.id);
        console.log('[DEBUG][MOVIMENTI] tx.payment_intent:', tx.payment_intent);
        console.log('[DEBUG][MOVIMENTI] tx.source:', tx.source);
        let paymentIntentToSearch = tx.payment_intent;
        if (!paymentIntentToSearch && tx.source && tx.source.startsWith('ch_')) {
          // Recupera la charge da Stripe e prendi il payment_intent
          try {
            const charge = await stripe.charges.retrieve(tx.source);
            chargePaymentIntent = charge.payment_intent;
            paymentIntentToSearch = charge.payment_intent;
            console.log('[DEBUG][MOVIMENTI][MATCH] Charge recuperata da Stripe:', charge.id, '-> payment_intent:', charge.payment_intent);
          } catch (e) {
            console.log('[DEBUG][MOVIMENTI][MATCH] Errore recupero charge Stripe:', tx.source, e.message);
          }
        }
        console.log('[DEBUG][MOVIMENTI][MATCH] tx.id:', tx.id, '| tx.source:', tx.source, '| tx.payment_intent:', tx.payment_intent, '| charge.payment_intent:', chargePaymentIntent, '| paymentIntentToSearch usato nella query:', paymentIntentToSearch);
        console.log('[DEBUG][MOVIMENTI] paymentIntentToSearch usato nella query:', paymentIntentToSearch);
        if (paymentIntentToSearch) {
          const likePattern = `%${paymentIntentToSearch}%`;
          console.log('[DEBUG][MOVIMENTI] CERCA PER payment_intent (LIKE pattern):', likePattern);
          transRes = await sql.query`SELECT TOP 1 idDealer, Descrizione, Payload FROM dbo.tbTransazioni WHERE Payload LIKE ${likePattern}`;
          console.log('[DEBUG][MOVIMENTI][QUERY RESULT]', transRes && transRes.recordset);
        }
        // Fallback: se ancora nulla, cerca per source
        if ((!transRes || transRes.recordset.length === 0) && tx.source) {
          console.log('[DEBUG][MOVIMENTI] CERCA PER source (fallback):', tx.source);
          transRes = await sql.query`SELECT TOP 1 idDealer, Descrizione, Payload FROM dbo.tbTransazioni WHERE Payload LIKE '%${tx.source}%'`;
        }
        if (transRes && transRes.recordset.length > 0) {
          console.log('[DEBUG][MOVIMENTI] transRes.recordset:', transRes.recordset);
          const row = transRes.recordset[0];
          console.log('[DEBUG][MOVIMENTI] idDealer trovato:', row.idDealer);
          const dealerRes = await sql.query`SELECT RagioneSociale FROM dbo.tbDealers WHERE IDDealer = ${row.idDealer}`;
          console.log('[DEBUG][MOVIMENTI] dealerRes.recordset:', dealerRes.recordset);
          if (dealerRes.recordset.length > 0) {
            dealer = dealerRes.recordset[0].RagioneSociale;
          }
          console.log('[DEBUG][MOVIMENTI] Dealer assegnato:', dealer);
          descrizione = row.Descrizione || '';
        } else {
          console.log('[DEBUG][MOVIMENTI] Nessuna transazione trovata per la ricerca. Dealer rimane vuoto.');
        }
      }
      result.push({
        data: tx.created ? new Date(tx.created * 1000).toLocaleString('it-IT') : '',
        dealer,
        tipo,
        importo: (tx.amount / 100).toFixed(2),
        valuta: tx.currency ? tx.currency.toUpperCase() : '',
        descrizione
      });
    }
    res.json({ success: true, data: result });
  } catch (err) {
    console.error('[STRIPE][MOVIMENTI] Errore:', err);
    res.status(500).json({ success: false, error: 'Errore recupero movimenti Stripe', details: err.message });
  }
});

// Endpoint di debug connessione DB
app.get('/api/debug-db', async (req, res) => {
  try {
    const sql = require('mssql');
    const pool = await sql.connect(dbConfig);
    const result = await pool.request().query('SELECT 1 as test');
    res.json({ status: 'success', result: result.recordset });
  } catch (err) {
    res.status(500).json({ status: 'error', error: err, message: err.message });
  }
});

// Endpoint di verifica della connessione al database
app.get('/api/check-db', async (req, res) => {
  try {
    const sql = require('mssql');
    const pool = await sql.connect(dbConfig);
    const result = await pool.request().query('SELECT name FROM sys.databases');
    res.json({
      status: 'success',
      databases: result.recordset,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('Errore nel test del database:', error);
    res.status(500).json({
      status: 'error',
      message: 'Errore durante il test del database',
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Endpoint di verifica della connessione al database specifico
app.get('/api/check-db-connection', async (req, res) => {
  try {
    const pool = await sql.connect(dbConfig);
    await pool.request().query('SELECT 1');
    res.json({ status: 'success', message: 'Connessione al database riuscita' });
  } catch (err) {
    res.status(500).json({ status: 'error', error: err.message });
  }
});

// Endpoint temporaneo per testare la verifica password ASP.NET Identity
app.post('/api/test-password', express.json(), (req, res) => {
  const { password, hash } = req.body;
  try {
    const result = aspnetIdentityPw.validatePassword(password, hash);
    res.json({ valid: result });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// CORS middleware per sviluppo
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  if (req.method === 'OPTIONS') {
    return res.sendStatus(200);
  }
  next();
});


// Endpoint per restituire i templates
import * as fs from 'fs/promises';
app.get('/api/templates', async (req, res) => {
  try {
    const data = await fs.readFile('/home/ubuntu/backend/templates.json', 'utf8');
    res.json(JSON.parse(data));
  } catch (err) {
    res.status(500).json({ error: 'Impossibile leggere templates.json', details: err.message });
  }
});

// Endpoint per il controllo dello stato del server
app.get('/health', async (req, res) => {
  try {
    // Verifica la connessione al database
    await sql.query('SELECT 1');
    
    res.json({
      status: 'ok',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      database: 'connected'
    });
  } catch (error) {
    console.error('Health check failed:', error);
    res.status(500).json({
      status: 'error',
      error: 'Database connection failed',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

app.post('/api/login', express.json(), async (req, res) => {
  console.log('Richiesta di login ricevuta:', {
    headers: req.headers,
    body: req.body,
    ip: req.ip,
    method: req.method,
    url: req.originalUrl
  });

  const { username, email, password } = req.body;
  const loginIdentifier = email || username;

  if (!loginIdentifier || !password) {
    console.log('Credenziali mancanti:', {
      email: !!email,
      username: !!username,
      password: !!password
    });
    return res.status(400).json({
      error: 'Credenziali mancanti',
      message: 'Inserisci email/username e password'
    });
  }

  try {
    await sql.connect(dbConfig);
    let userType = null;
    let user = null;
    let ruoli = [];
    let agenteNome = null;

    // 1. Prova login come agente (ASP.NET Identity)
    let agentResult = await new sql.Request()
      .input('username', sql.NVarChar, loginIdentifier)
      .query(`SELECT TOP 1 * FROM dbo.AspNetUsers WHERE UserName = @username OR Email = @username`);
    if (agentResult.recordset && agentResult.recordset.length > 0) {
      userType = 'agente';
      user = agentResult.recordset[0];
      console.log('[LOGIN] Utente agente trovato:', user);
      // Verifica password hash ASP.NET Identity
      const hash = user.PasswordHash;
      // Recupera ruoli e verifica se l'utente ha il ruolo AGENTE normalizzato
      const agentRoleResult = await new sql.Request()
        .input('userId', sql.NVarChar, user.Id)
        .query(`SELECT r.Name, r.NormalizedName FROM dbo.AspNetUserRoles ur JOIN dbo.AspNetRoles r ON ur.RoleId = r.Id WHERE ur.UserId = @userId`);
      ruoli = agentRoleResult.recordset.map(r => r.Name);
      const isAgente = agentRoleResult.recordset.some(r => r.NormalizedName === 'AGENTE');
      const isMaster = agentRoleResult.recordset.some(r => r.NormalizedName === 'MASTER');
      const isMasterProdotti = agentRoleResult.recordset.some(r => r.NormalizedName === 'MASTERPRODOTTI');
      const isSuperMaster = agentRoleResult.recordset.some(r => r.NormalizedName === 'SUPERMASTER');
      if (isSuperMaster) {
        // Autentica come supermaster
        console.log('[LOGIN] Utente AspNetUsers con ruolo SUPERMASTER:', loginIdentifier);
        const isPasswordValid = await aspnetIdentityPw.validatePassword(password, user.PasswordHash);
        if (!isPasswordValid) {
          console.log('[LOGIN] Password non valida per supermaster:', loginIdentifier);
          return res.status(401).json({
            error: 'Credenziali non valide',
            message: 'La password inserita non è corretta.'
          });
        }
        const tokenPayload = {
          userId: user.Id,
          email: user.Email,
          ruoli,
          supermaster: true
        };
        const token = jwt.sign(tokenPayload, process.env.JWT_SECRET, { expiresIn: '2h' });
        return res.json({
          token,
          ruoli,
          userType: 'supermaster'
        });
      } else if (!isAgente && isMaster) {
        // Autentica come master
        console.log('[LOGIN] Utente AspNetUsers con ruolo MASTER:', loginIdentifier);
        console.log('[DEBUG] MASTER PasswordHash:', user.PasswordHash);
        const isPasswordValid = await aspnetIdentityPw.validatePassword(password, user.PasswordHash);
        if (!isPasswordValid) {
          console.log('[LOGIN] Password non valida per master:', loginIdentifier);
          return res.status(401).json({
            error: 'Credenziali non valide',
            message: 'La password inserita non è corretta.'
          });
        }
        const tokenPayload = {
          userId: user.Id,
          email: user.Email,
          ruoli,
          master: true
        };
        const token = jwt.sign(tokenPayload, process.env.JWT_SECRET, { expiresIn: '2h' });
        return res.json({
          token,
          ruoli,
          userType: 'master'
        });
      } else if (!isAgente && isMasterProdotti) {
        // Autentica come masterprodotti
        console.log('[LOGIN] Utente AspNetUsers con ruolo MASTERPRODOTTI:', loginIdentifier);
        const isPasswordValid = await aspnetIdentityPw.validatePassword(password, user.PasswordHash);
        if (!isPasswordValid) {
          console.log('[LOGIN] Password non valida per masterprodotti:', loginIdentifier);
          return res.status(401).json({
            error: 'Credenziali non valide',
            message: 'La password inserita non è corretta.'
          });
        }
        const tokenPayload = {
          userId: user.Id,
          email: user.Email,
          ruoli,
          masterprodotti: true
        };
        const token = jwt.sign(tokenPayload, process.env.JWT_SECRET, { expiresIn: '2h' });
        return res.json({
          token,
          ruoli,
          userType: 'masterprodotti'
        });
      } else if (!isAgente) {
        console.log('[LOGIN] Utente AspNetUsers senza ruolo "agenti" né "master", passo a dealer:', loginIdentifier);
        // Skip agent/master login, proceed to dealer login logic
      } else {
        // Verifica password hash ASP.NET Identity SOLO se ha ruolo 'agenti'
        const hash = user.PasswordHash;
        const isPasswordValid = await aspnetIdentityPw.validatePassword(password, hash);
        if (!isPasswordValid) {
          console.log('[LOGIN] Password non valida per agente:', loginIdentifier);
          return res.status(401).json({
            error: 'Credenziali non valide',
            message: 'La password inserita non è corretta.'
          });
        }
        // Recupera CodiceAgenteLarge da tbAgenti tramite RecapitoEmail
        let agenteNomeDB = null;
        try {
          const agentiQuery = await new sql.Request()
            .input('email', sql.NVarChar, user.Email || user.UserName)
            .query("SELECT CodiceAgenteLarge FROM dbo.tbAgenti WHERE RecapitoEmail = @email");
          if (agentiQuery.recordset && agentiQuery.recordset.length > 0) {
            agenteNomeDB = agentiQuery.recordset[0].CodiceAgenteLarge;
          }
        } catch (e) {
          console.error('[LOGIN] Errore lookup CodiceAgenteLarge da tbAgenti:', e);
        }
        agenteNome = agenteNomeDB || user.Nome || user.UserName || null;
        // Genera JWT
        const tokenPayload = {
          userId: user.Id,
          email: user.Email,
          ruoli,
          agenteNome
        };
        console.log('[LOGIN] Generazione token per agente:', tokenPayload);
        const token = jwt.sign(tokenPayload, process.env.JWT_SECRET, { expiresIn: '2h' });
        return res.json({
          token,
          ruoli,
          agenteNome: agenteNome,
          userType: 'agente'
        });
      }
    }

    // 2. Prova login come dealer (legacy)
    const request = new sql.Request();
    request.input('email', sql.NVarChar, loginIdentifier);
    const query = `SELECT * FROM dbo.tbDealers WHERE RecapitoEmail = @email`;
    console.log('Esecuzione query dealer:', query, 'con email:', loginIdentifier);
    const result = await request.query(query);
    if (!result.recordset || result.recordset.length === 0) {
      console.log('Nessun dealer trovato per email:', loginIdentifier);
      return res.status(401).json({
        error: 'Credenziali non valide',
        message: 'Nessun account trovato con questa email.'
      });
    }
    const dealer = result.recordset[0];
    // Password in chiaro (legacy)
    const isPasswordValid = password === dealer.TmpPasswd;
    if (!isPasswordValid) {
      console.log('Password non valida per il dealer:', dealer.RecapitoEmail);
      return res.status(401).json({
        error: 'Credenziali non valide',
        message: 'La password inserita non è corretta.'
      });
    }
    // Dealer: genera JWT con ruolo dealer
    const tokenPayload = {
      userId: dealer.IDDealer,
      email: dealer.RecapitoEmail,
      dealerId: dealer.IDDealer,
      phoneNumber: dealer.RecapitoCell || '',
      ruoli: ['dealer'],
      dealerName: dealer.RagioneSociale || dealer.RecapitoEmail,
      agenteNome: dealer.AGENTE || null  // Aggiunto il campo agenteNome al token
    };
    const token = jwt.sign(tokenPayload, process.env.JWT_SECRET, { expiresIn: '2h' });
    // Formatta telefono
    let phoneNumber = 'web_user';
    if (dealer.RecapitoCell) {
      const cleanNumber = dealer.RecapitoCell.replace(/\D/g, '').slice(-10);
      if (cleanNumber.length === 10) {
        phoneNumber = '39' + cleanNumber;
      }
    }
    // DISABILITATO: Invio notifica WhatsApp su login dealer
    /*
    if (dealer.RecapitoCell) {
      const whatsappPayload = {
        to: phoneNumber,
        message: `Login effettuato: accesso area riservata dealer ${dealer.RagioneSociale} (${dealer.RecapitoEmail})`
      };
      try {
        console.log('[NOTIFICA][WHATSAPP][LOGIN][INVIO] Numero:', whatsappPayload.to, '| Messaggio:', whatsappPayload.message);
        const waResp = await axios.post(process.env.WHATSAPP_BOT_URL, whatsappPayload);
        console.log('[NOTIFICA][WHATSAPP][LOGIN][SUCCESS] Risposta bot:', waResp.data);
      } catch (waErr) {
        console.error('[NOTIFICA][WHATSAPP][LOGIN][ERRORE]', waErr);
      }
    }
    */
    return res.json({
      token,
      dealerName: dealer.RagioneSociale || dealer.RecapitoEmail,
      phoneNumber,
      userType: 'dealer',
      ruoli: ['dealer']
    });
  } catch (err) {
    console.error('Errore durante il login:', err);
    res.status(500).json({
      error: 'Errore server',
      details: err.message,
      stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
    });
  }
});

app.get('/api/attivazioni', authenticateToken, async (req, res) => {
  try {
    // Estrai il token JWT dall'header Authorization
    const authHeader = req.headers['authorization'];
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token mancante' });
    }
    const token = authHeader.split(' ')[1];
    let decoded;
    try {
      // Token già verificato dal middleware; dati utente disponibili in req.user
      if (!req.user.userId) {
        return res.status(401).json({ error: 'Token non valido: userId mancante' });
      }
    } catch (err) {
      return res.status(401).json({ error: 'Token non valido o scaduto' });
    }

    // Usa dealerId dal token JWT
    const dealerId = req.user.dealerId;
    if (!dealerId) {
      return res.status(401).json({ error: 'ID dealer non valido' });
    }

    console.log('Esecuzione query attivazioni per dealer ID:', dealerId);
    
    try {
      // Trova la ragione sociale del dealer
      await sql.connect(dbConfig);
      const request = new sql.Request();
      request.input('idDealer', sql.Int, dealerId);
      const dealerQuery = `SELECT RagioneSociale FROM dbo.tbDealers WHERE IDDealer = @idDealer`;
      const dealerRes = await request.query(dealerQuery);
      
      if (!dealerRes.recordset.length) {
        return res.status(404).json({ error: 'Dealer non trovato' });
      }
      
      const ragioneSociale = dealerRes.recordset[0].RagioneSociale;
      
      // Query per ottenere le ultime 5 attivazioni
      const query = `
        SELECT TOP 5
          CONVERT(VARCHAR(10), o.DataOra, 120) AS Data,
          offr.Titolo AS Titolo,
          offr.Tipo AS Tipo,
          offr.Segmento AS Segmento,
          so.StatoEsteso AS Stato
        FROM dbo.tbOrdini o
        LEFT JOIN dbo.tbStatiOrdini so ON o.Stato = so.IDStato
        LEFT JOIN dbo.TbOfferte offr ON o.idOfferta = offr.IDOfferta
        WHERE o.idDealer = @idDealer
        ORDER BY o.DataOra DESC`;
      
      console.log('Esecuzione query attivazioni:', query);
      
      const result = await request.query(query);
      
      console.log('Risultati query attivazioni:', JSON.stringify(result.recordset, null, 2));
      
      return res.json({ 
        ragioneSociale, 
        attivazioni: result.recordset || [] 
      });
      
    } catch (err) {
      console.error('Errore durante l\'esecuzione della query attivazioni:', err);
      throw err; // Rilancia l'errore per la gestione nel blocco catch esterno
    }
  } catch (err) {
    console.error('Errore in /api/attivazioni:', err);
    // Verifica se la risposta è già stata inviata
    if (!res.headersSent) {
      return res.status(500).json({ 
        error: 'Errore del server', 
        details: err.message,
        code: err.code
      });
    } else {
      console.error('Tentativo di inviare una risposta multipla per la stessa richiesta');
    }
  }
});

app.get('/api/ordini', authenticateToken, async (req, res) => {
  try {
    // Estrai il token JWT dall'header Authorization
    const authHeader = req.headers['authorization'];
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token mancante' });
    }
    const token = authHeader.substring(7);
    let email;
    try {
      const // Token già verificato dal middleware; dati utente disponibili in req.user
      email = req.user.email;
    } catch (err) {
      return res.status(401).json({ error: 'Token non valido' });
    }
    await sql.connect(dbConfig);
    const request = new sql.Request();
    request.input('email', sql.NVarChar, email);
    // Trova idDealer e RagioneSociale dell'utente loggato
    const dealerQuery = `SELECT TOP 1 IDDealer, RagioneSociale FROM dbo.tbDealers WHERE RecapitoEmail = @email`;
    const dealerRes = await request.query(dealerQuery);
    if (!dealerRes.recordset.length) {
      return res.status(404).json({ error: 'Dealer non trovato per questa email' });
    }
    const idDealer = dealerRes.recordset[0].IDDealer;
    const ragioneSociale = dealerRes.recordset[0].RagioneSociale;
    // Query per ultimi 5 ordini del dealer
    request.input('idDealer', sql.Int, idDealer);
    const query = `
      SELECT TOP 5
        CONVERT(VARCHAR(10), op.DataOra, 120) AS Data,
        of.Titolo AS Prodotto,
        of.Tipo AS Tipo,
        op.TotaleOrdine AS Importo,
        op.SpeseSpedizione,
        op.idStatoOrdineProdotto AS Stato
      FROM dbo.tbOrdiniProdotti op
      LEFT JOIN dbo.tbOfferte of ON op.idOfferta = of.IDOfferta
      WHERE op.idDealer = @idDealer
      ORDER BY op.DataOra DESC`;

    try {
      const result = await request.query(query);
      res.json({ ragioneSociale, ordini: result.recordset });
    } catch (err) {
      console.error('ERRORE QUERY ORDINI:', err.message, err.stack);
      res.status(500).json({ error: 'Errore server nella query ordini', details: err.message });
    }
  } catch (err) {
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});


// --- API: ULTIMI ORDINI ---
// GET /api/ultimi-ordini
app.get('/api/ultimi-ordini', authenticateToken, async (req, res) => {
  try {
    // Autenticazione JWT
    const authHeader = req.headers['authorization'];
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token mancante' });
    }

    // Token già verificato dal middleware; dati utente disponibili in req.user
    if (!req.user.userId) {
      return res.status(401).json({ error: 'Token non valido: userId mancante' });
    }

    const dealerId = req.user.dealerId;
    const userEmail = req.user.email;

    await sql.connect(dbConfig);
    if (dealerId) {
      // --- Modalità DEALER ---
      console.log('[ULTIMI-ORDINI] DealerId presente:', dealerId);
      const request = new sql.Request();
      request.input('idDealer', sql.Int, dealerId);
      const query = `
        SELECT TOP 5
          CONVERT(VARCHAR(10), o.DataOra, 120) AS Data,
          offr.Titolo AS Prodotto,
          offr.Tipo AS Tipo,
          o.TotaleOrdine AS Importo,
          o.SpeseSpedizione,
          so.StatoEsteso AS Stato
        FROM dbo.tbOrdiniProdotti o
        LEFT JOIN dbo.tbStatiOrdiniProdotti so ON o.idStatoOrdineProdotto = so.IDStato
        LEFT JOIN dbo.tbDettagliOrdiniProdotti dop ON o.IDOrdineProdotto = dop.idOrdineProdotto
        LEFT JOIN dbo.tbOfferte offr ON dop.idOfferta = offr.IDOfferta
        WHERE o.idDealer = @idDealer
        ORDER BY o.DataOra DESC`;
      const result = await request.query(query);
      console.log('[ULTIMI-ORDINI][DEALER] Risultati:', JSON.stringify(result.recordset, null, 2));
      return res.json({ ordini: result.recordset || [] });
    } else if (userEmail) {
      // --- Modalità AGENTE ---
      console.log('[ULTIMI-ORDINI] DealerId assente, modalità agente. Email:', userEmail);
      // Trova CodiceAgenteLarge tramite email
      const agenteRes = await new sql.Request()
        .input('email', sql.NVarChar, userEmail)
        .query("SELECT CodiceAgenteLarge FROM dbo.tbAgenti WHERE RecapitoEmail = @email");
      if (!agenteRes.recordset.length || !agenteRes.recordset[0].CodiceAgenteLarge) {
        console.log('[ULTIMI-ORDINI][AGENTE] Nessun CodiceAgenteLarge trovato per email:', userEmail);
        return res.json({ ordini: [] });
      }
      const agenteNome = agenteRes.recordset[0].CodiceAgenteLarge;
      console.log('[ULTIMI-ORDINI][AGENTE] agenteNome (CodiceAgenteLarge) trovato:', agenteNome);
      const request = new sql.Request();
      request.input('agente', sql.NVarChar, agenteNome);
      const query = `
        SELECT TOP 5
          CONVERT(VARCHAR(10), o.DataOra, 120) AS Data,
          offr.Titolo AS Prodotto,
          d.RagioneSociale AS Dealer,
          CASE WHEN o.OrdineDaAgente = 0 THEN 'DIRETTO' WHEN o.OrdineDaAgente = 1 THEN 'AGENTE' ELSE '' END AS Inserimento,
          offr.Tipo AS Tipo,
          o.TotaleOrdine AS Importo,
          so.StatoEsteso AS Stato
        FROM dbo.tbOrdiniProdotti o
        LEFT JOIN dbo.tbDealers d ON o.idDealer = d.IDDealer
        LEFT JOIN dbo.tbStatiOrdiniProdotti so ON o.idStatoOrdineProdotto = so.IDStato
        LEFT JOIN dbo.tbDettagliOrdiniProdotti dop ON o.IDOrdineProdotto = dop.idOrdineProdotto
        LEFT JOIN dbo.tbOfferte offr ON dop.idOfferta = offr.IDOfferta
        WHERE d.AGENTE = @agente
        ORDER BY o.DataOra DESC`;
      const result = await request.query(query);
      console.log('[ULTIMI-ORDINI][AGENTE] Risultati:', JSON.stringify(result.recordset, null, 2));
      return res.json({ ordini: result.recordset || [] });
    } else {
      console.log('[ULTIMI-ORDINI] Né dealerId né email presenti nel token.');
      return res.json({ ordini: [] });
    }
  } catch (err) {
    console.error('Errore in /api/ultimi-ordini:', err);
    if (!res.headersSent) {
      return res.status(500).json({ 
        error: 'Errore del server', 
        details: err.message,
        code: err.code
      });
    } else {
      console.error('Tentativo di inviare una risposta multipla per la stessa richiesta');
    }
  }
});

// --- API: ATTIVAZIONI (POST) ---
// Multer setup for parsing multipart/form-data
const upload = multer();

app.post('/api/attivazioni', authenticateToken, upload.any(), async (req, res) => {
  console.log('[DEBUG] /api/attivazioni req.body:', req.body);
  console.log('[DEBUG] /api/attivazioni req.files:', req.files);
  const transaction = new sql.Transaction();
  try {
    await sql.connect(dbConfig);
    await transaction.begin();
    const request = new sql.Request(transaction);

    // 1. Estrai dati principali dal body
    const {
      idOfferta,
      files = [], // [{ tipoFile, fileUID, nomeFile }]
      intestatario = {}, // dati intestatario (JSON)
      altriDati = {},    // altri dati ordine (JSON)
      simType = null,
      simCount: originalSimCount = null,
      noteInterne = null,
      noteDealer = null,
      stato = 0, // DA_ELABORARE
      plafondCost = 0, // se > 0 scala il plafond
      utente = null,   // email utente
    } = req.body;
    // Default simCount to 1 if not provided or invalid
    const simCount = originalSimCount && !isNaN(originalSimCount) ? Number(originalSimCount) : 1;
    const idDealer = req.user.dealerId;
    const idAgente = req.user.userId || null;
    const now = new Date();

    // 2. Inserisci in tbOrdini
    const ordineResult = await request
      .input('DataOra', sql.DateTime, now)
      .input('idAgente', sql.Int, idAgente)
      .input('idDealer', sql.Int, idDealer)
      .input('idOfferta', sql.Int, idOfferta)
      .input('Stato', sql.Int, stato)
      .input('Utente', sql.NVarChar, utente)
      .input('NoteInterne', sql.NVarChar, noteInterne)
      .input('NoteDealer', sql.NVarChar, noteDealer)
      .input('SIMTYPE', sql.NVarChar, simType)
      .input('SIMCOUNT', sql.Int, simCount)
      .input('DataStato', sql.DateTime, now)
      .query(`INSERT INTO dbo.tbOrdini (DataOra, idAgente, idDealer, idOfferta, Stato, Utente, NoteInterne, NoteDealer, SIMTYPE, SIMCOUNT, DataStato)
              OUTPUT INSERTED.IDOrdine
              VALUES (@DataOra, @idAgente, @idDealer, @idOfferta, @Stato, @Utente, @NoteInterne, @NoteDealer, @SIMTYPE, @SIMCOUNT, @DataStato)`);
    const idOrdine = ordineResult.recordset[0].IDOrdine;

    // 3. Inserisci in tbDatiIntestario
    await (new sql.Request(transaction))
      .input('IDOrdine', sql.Int, idOrdine)
      .input('Tipo', sql.Int, 0)
      .input('Payload', sql.NVarChar(sql.MAX), JSON.stringify(
        Object.keys(intestatario).length > 0 ? intestatario :
        // fallback: build intestatario from req.body fields except meta/technical fields
        Object.fromEntries(
          Object.entries(req.body).filter(([key]) => ![
            'idOfferta', 'files', 'altriDati', 'simType', 'simCount', 'noteInterne', 'noteDealer', 'stato', 'plafondCost', 'utente'
          ].includes(key))
        )
      ))
      .query(`INSERT INTO dbo.tbDatiIntestario (IDOrdine, Tipo, Payload) VALUES (@IDOrdine, @Tipo, @Payload)`);

    // 4. Inserisci in tbDatiOrdine
    await (new sql.Request(transaction))
      .input('IDOrdine', sql.Int, idOrdine)
      .input('AppliedConfig', sql.NVarChar, null)
      .input('Payload', sql.NVarChar(sql.MAX), JSON.stringify(
        (() => {
          const allowed = [
            'INTESTATARIO_METODO_DI_PAGAMENTO',
            'IBAN',
            'NUMERO_DI_RETE_FISSA_DA_PASSARE',
            'GESTORE_DI_PROVENIENZA',
            'CODICE_DI_MIGRAZIONE',
            'TIPO_DI_DOCUMENTO',
            'NUMERO_DOCUMENTO',
            'DATA_E_LUOGO_RILASCIO_DOCUMENTO',
            'ENTE_RILASCIO_DOCUMENTO',
            'SCADENZA_DOCUMENTO',
            'NUMERO_DA_PASSARE',
            'SERIALE_SIM_DA_ATTIVARE',
            'NOTE'
          ];
          const filtered = {};
          for (const k of allowed) {
            if (req.body[k] !== undefined && req.body[k] !== '') filtered[k] = req.body[k];
          }
          return filtered;
        })()
      ))
      .query(`INSERT INTO dbo.tbDatiOrdine (IDOrdine, AppliedConfig, Payload) VALUES (@IDOrdine, @AppliedConfig, @Payload)`);

    // 5. Inserisci file in tbFileOrdine
    const { v4: uuidv4 } = require('uuid');
    for (const file of req.files || []) {
      // Map multer fields to expected DB structure
      const tipoFile = file.fieldname;
      const originalName = file.originalname;
      const fileUID = uuidv4();
      const nomeFile = `${fileUID}_${originalName}`;
      await (new sql.Request(transaction))
        .input('IDOrdine', sql.Int, idOrdine)
        .input('TipoFile', sql.NVarChar, tipoFile)
        .input('FileUID', sql.NVarChar, fileUID)
        .input('NomeFile', sql.NVarChar, nomeFile)
        .input('Payload', sql.NVarChar, '-')
        .query(`INSERT INTO dbo.tbFileOrdine (IDOrdine, TipoFile, FileUID, NomeFile, Payload) VALUES (@IDOrdine, @TipoFile, @FileUID, @NomeFile, @Payload)`);
    }

    // 6. Scala plafond in tbTransazioni se serve
    if (plafondCost && plafondCost < 0) {
      await request
        .input('Descrizione', sql.NVarChar, `ORDINE ${idOrdine}`)
        .input('idDealer', sql.Int, idDealer)
        .input('Crediti', sql.Int, plafondCost)
        .input('DataOra', sql.DateTime, now)
        .input('idAgente', sql.Int, idAgente)
        .input('Fonte', sql.NVarChar, 'OFF')
        .input('Payload', sql.NVarChar, null)
        .input('Note', sql.NVarChar, null)
        .input('Riferimento', sql.Int, idOrdine)
        .query(`INSERT INTO dbo.tbTransazioni (Descrizione, idDealer, Crediti, DataOra, idAgente, Fonte, Payload, Note, Riferimento)
                VALUES (@Descrizione, @idDealer, @Crediti, @DataOra, @idAgente, @Fonte, @Payload, @Note, @Riferimento)`);
    }

    await transaction.commit();
    return res.json({ success: true, idOrdine });
  } catch (err) {
    if (transaction._aborted !== true) {
      await transaction.rollback();
    }
    console.error('[ATTIVAZIONE][ERRORE]', err);
    res.status(500).json({ error: 'Errore durante l\'inserimento ordine', details: err.message });
  } finally {
    // Chiudi la transazione
  }
});

app.get('/api/ultime-attivazioni-agente', authenticateToken, async (req, res) => {
  try {
    const agenteNome = req.user.agenteNome;
    const operatore = req.query.operatore;
    if (!agenteNome) {
      return res.status(400).json({ error: 'Nome agente mancante nel token' });
    }
    await sql.connect(dbConfig);

    let attivazioniQuery;
    let request = new sql.Request();
    if (!operatore || operatore === 'FASTWEB') {
      attivazioniQuery = `
        WITH OrdiniUnici AS (
          SELECT *,
                 ROW_NUMBER() OVER (PARTITION BY [Codice Ordine] ORDER BY TRY_CAST([Batch] AS DATETIME) DESC) AS rn
          FROM dbo.InseritoFW
        )
        SELECT TOP 5
          FORMAT(TRY_CAST(o.[Batch] AS DATETIME), 'dd.MM.yyyy') AS Data,
          o.[Valore],
          d.[RagioneSociale],
          o.[Segmento],
          o.[Tipo Ordine]
        FROM OrdiniUnici o
        LEFT JOIN dbo.tbdealers d
          ON o.[Codice Comsy Tecnico Attuale] = d.[COMSY1]
          OR o.[Codice Comsy Tecnico Attuale] = d.[COMSY2]
        WHERE o.rn = 1
          AND d.[AGENTE] LIKE @agente
        ORDER BY TRY_CAST(o.[Batch] AS DATETIME) DESC
      `;
      request = request.input('agente', sql.NVarChar, `%${agenteNome}%`);
    } else if (operatore === 'FASTWEB ENERGIA') {
      attivazioniQuery = `
        WITH OrdiniEnergiaUnici AS (
            SELECT *,
                   ROW_NUMBER() OVER (
                       PARTITION BY [Codice Contratto]
                       ORDER BY TRY_CAST([Batch] AS DATETIME) DESC
                   ) AS rn
            FROM dbo.FWEnergiaImporter
        )
        SELECT TOP 5
            FORMAT(TRY_CAST(e.[Batch] AS DATETIME), 'dd.MM.yyyy') AS Data,
            e.[Nome Offerta Vendita] AS Valore,
            d.[RagioneSociale],
            e.[Segmento ] AS Segmento,
            e.[Tipo Cliente] AS [Tipo Ordine]
        FROM OrdiniEnergiaUnici e
        LEFT JOIN dbo.tbdealers d
            ON e.[Codice Comsy/Order Owner (Report!DBSELLER)] = d.[COMSY1]
            OR e.[Codice Comsy/Order Owner (Report!DBSELLER)] = d.[COMSY2]
        WHERE e.rn = 1
          AND d.[AGENTE] LIKE @agente
        ORDER BY TRY_CAST(e.[Batch] AS DATETIME) DESC
      `;
      request = request.input('agente', sql.NVarChar, `%${agenteNome}%`);
    } else if (operatore === 'SKY TV') {
      attivazioniQuery = `
        WITH OrdiniUnici AS (
            SELECT
                o.[IDOrdine],
                o.[DataStato],
                o.[idDealer],
                o.[idOfferta],
                o.[Stato],
                f.[Titolo],
                f.[Segmento],
                f.[Tipo],
                ROW_NUMBER() OVER (
                    PARTITION BY COALESCE(o.[ExtOrder], CONVERT(VARCHAR(20), o.[IDOrdine]))
                    ORDER BY TRY_CAST(o.[DataStato] AS DATETIME) DESC
                ) AS rn
            FROM dbo.tbOrdini o
            INNER JOIN dbo.tbOfferte f
                ON o.[idOfferta] = f.[IDOfferta]
            INNER JOIN dbo.tbDealers d
                ON o.[idDealer] = d.[idDealer]
            WHERE o.[Stato] = 1
              AND f.[IDOperatore] = 3
              AND d.[AGENTE] = @agente
        )
        SELECT TOP 5
            FORMAT(TRY_CAST(o.[DataStato] AS DATETIME), 'dd.MM.yyyy') AS Data,
            o.[Titolo] AS Valore,
            d.[RagioneSociale],
            o.[Segmento],
            o.[Tipo] AS [Tipo Ordine]
        FROM OrdiniUnici o
        INNER JOIN dbo.tbDealers d
            ON o.[idDealer] = d.[idDealer]
        WHERE o.rn = 1
        ORDER BY TRY_CAST(o.[DataStato] AS DATETIME) DESC
      `;
      request = request.input('agente', sql.NVarChar, agenteNome);
    } else if (operatore === 'SKY MOBILE') {
      attivazioniQuery = `
        WITH OrdiniUnici AS (
            SELECT
                o.[IDOrdine],
                o.[DataStato],
                o.[idDealer],
                o.[idOfferta],
                o.[Stato],
                f.[Titolo],
                f.[Segmento],
                f.[Tipo],
                ROW_NUMBER() OVER (
                    PARTITION BY COALESCE(o.[ExtOrder], CONVERT(VARCHAR(20), o.[IDOrdine]))
                    ORDER BY TRY_CAST(o.[DataStato] AS DATETIME) DESC
                ) AS rn
            FROM dbo.tbOrdini o
            INNER JOIN dbo.tbOfferte f
                ON o.[idOfferta] = f.[IDOfferta]
            INNER JOIN dbo.tbDealers d
                ON o.[idDealer] = d.[idDealer]
            WHERE o.[Stato] = 1
              AND f.[IDOperatore] = 8
              AND d.[AGENTE] = @agente
        )
        SELECT TOP 5
            FORMAT(TRY_CAST(o.[DataStato] AS DATETIME), 'dd.MM.yyyy') AS Data,
            o.[Titolo] AS Valore,
            d.[RagioneSociale],
            o.[Segmento],
            o.[Tipo] AS [Tipo Ordine]
        FROM OrdiniUnici o
        INNER JOIN dbo.tbDealers d
            ON o.[idDealer] = d.[idDealer]
        WHERE o.rn = 1
        ORDER BY TRY_CAST(o.[DataStato] AS DATETIME) DESC
      `;
      request = request.input('agente', sql.NVarChar, agenteNome);
    } else if (operatore === 'SKY BUSINESS') {
      attivazioniQuery = `
        WITH OrdiniUnici AS (
            SELECT
                o.[IDOrdine],
                o.[DataStato],
                o.[idDealer],
                o.[idOfferta],
                o.[Stato],
                f.[Titolo],
                f.[Segmento],
                f.[Tipo],
                ROW_NUMBER() OVER (
                    PARTITION BY COALESCE(o.[ExtOrder], CONVERT(VARCHAR(20), o.[IDOrdine]))
                    ORDER BY TRY_CAST(o.[DataStato] AS DATETIME) DESC
                ) AS rn
            FROM dbo.tbOrdini o
            INNER JOIN dbo.tbOfferte f
                ON o.[idOfferta] = f.[IDOfferta]
            INNER JOIN dbo.tbDealers d
                ON o.[idDealer] = d.[idDealer]
            WHERE o.[Stato] = 1
              AND f.[IDOperatore] = 12
              AND d.[AGENTE] = @agente
        )
        SELECT TOP 5
            FORMAT(TRY_CAST(o.[DataStato] AS DATETIME), 'dd.MM.yyyy') AS Data,
            o.[Titolo] AS Valore,
            d.[RagioneSociale],
            o.[Segmento],
            o.[Tipo] AS [Tipo Ordine]
        FROM OrdiniUnici o
        INNER JOIN dbo.tbDealers d
            ON o.[idDealer] = d.[idDealer]
        WHERE o.rn = 1
        ORDER BY TRY_CAST(o.[DataStato] AS DATETIME) DESC
      `;
      request = request.input('agente', sql.NVarChar, agenteNome);
    } else if (operatore === 'ILIAD') {
      attivazioniQuery = `
        WITH OrdiniUnici AS (
            SELECT
                o.[IDOrdine],
                o.[DataStato],
                o.[idDealer],
                o.[idOfferta],
                o.[Stato],
                f.[Titolo],
                f.[Segmento],
                f.[Tipo],
                ROW_NUMBER() OVER (
                    PARTITION BY COALESCE(o.[ExtOrder], CONVERT(VARCHAR(20), o.[IDOrdine]))
                    ORDER BY TRY_CAST(o.[DataStato] AS DATETIME) DESC
                ) AS rn
            FROM dbo.tbOrdini o
            INNER JOIN dbo.tbOfferte f
                ON o.[idOfferta] = f.[IDOfferta]
            INNER JOIN dbo.tbDealers d
                ON o.[idDealer] = d.[idDealer]
            WHERE o.[Stato] = 1
              AND f.[IDOperatore] = 5
              AND d.[AGENTE] = @agente
        )
        SELECT TOP 5
            FORMAT(TRY_CAST(o.[DataStato] AS DATETIME), 'dd.MM.yyyy') AS Data,
            o.[Titolo] AS Valore,
            d.[RagioneSociale],
            o.[Segmento],
            o.[Tipo] AS [Tipo Ordine]
        FROM OrdiniUnici o
        INNER JOIN dbo.tbDealers d
            ON o.[idDealer] = d.[idDealer]
        WHERE o.rn = 1
        ORDER BY TRY_CAST(o.[DataStato] AS DATETIME) DESC
      `;
      request = request.input('agente', sql.NVarChar, agenteNome);
    } else if (operatore === 'KENA MOBILE') {
      attivazioniQuery = `
        WITH OrdiniUnici AS (
            SELECT
                o.[IDOrdine],
                o.[DataStato],
                o.[idDealer],
                o.[idOfferta],
                o.[Stato],
                f.[Titolo],
                f.[Segmento],
                f.[Tipo],
                ROW_NUMBER() OVER (
                    PARTITION BY COALESCE(o.[ExtOrder], CONVERT(VARCHAR(20), o.[IDOrdine]))
                    ORDER BY TRY_CAST(o.[DataStato] AS DATETIME) DESC
                ) AS rn
            FROM dbo.tbOrdini o
            INNER JOIN dbo.tbOfferte f
                ON o.[idOfferta] = f.[IDOfferta]
            INNER JOIN dbo.tbDealers d
                ON o.[idDealer] = d.[idDealer]
            WHERE o.[Stato] = 1
              AND f.[IDOperatore] = 6
              AND d.[AGENTE] = @agente
        )
        SELECT TOP 5
            FORMAT(TRY_CAST(o.[DataStato] AS DATETIME), 'dd.MM.yyyy') AS Data,
            o.[Titolo] AS Valore,
            d.[RagioneSociale],
            o.[Segmento],
            o.[Tipo] AS [Tipo Ordine]
        FROM OrdiniUnici o
        INNER JOIN dbo.tbDealers d
            ON o.[idDealer] = d.[idDealer]
        WHERE o.rn = 1
        ORDER BY TRY_CAST(o.[DataStato] AS DATETIME) DESC
      `;
      request = request.input('agente', sql.NVarChar, agenteNome);
    } else if (operatore === '1MOBILE') {
      attivazioniQuery = `
        WITH OrdiniUnici AS (
            SELECT
                o.[IDOrdine],
                o.[DataStato],
                o.[idDealer],
                o.[idOfferta],
                o.[Stato],
                f.[Titolo],
                f.[Segmento],
                f.[Tipo],
                ROW_NUMBER() OVER (
                    PARTITION BY COALESCE(o.[ExtOrder], CONVERT(VARCHAR(20), o.[IDOrdine]))
                    ORDER BY TRY_CAST(o.[DataStato] AS DATETIME) DESC
                ) AS rn
            FROM dbo.tbOrdini o
            INNER JOIN dbo.tbOfferte f
                ON o.[idOfferta] = f.[IDOfferta]
            INNER JOIN dbo.tbDealers d
                ON o.[idDealer] = d.[idDealer]
            WHERE o.[Stato] = 1
              AND f.[IDOperatore] = 7
              AND d.[AGENTE] = @agente
        )
        SELECT TOP 5
            FORMAT(TRY_CAST(o.[DataStato] AS DATETIME), 'dd.MM.yyyy') AS Data,
            o.[Titolo] AS Valore,
            d.[RagioneSociale],
            o.[Segmento],
            o.[Tipo] AS [Tipo Ordine]
        FROM OrdiniUnici o
        INNER JOIN dbo.tbDealers d
            ON o.[idDealer] = d.[idDealer]
        WHERE o.rn = 1
        ORDER BY TRY_CAST(o.[DataStato] AS DATETIME) DESC
      `;
      request = request.input('agente', sql.NVarChar, agenteNome);
    } else if (operatore === 'WEEDOO') {
      attivazioniQuery = `
        WITH OrdiniUnici AS (
            SELECT
                o.[IDOrdine],
                o.[DataStato],
                o.[idDealer],
                o.[idOfferta],
                o.[Stato],
                f.[Titolo],
                f.[Segmento],
                f.[Tipo],
                ROW_NUMBER() OVER (
                    PARTITION BY COALESCE(o.[ExtOrder], CONVERT(VARCHAR(20), o.[IDOrdine]))
                    ORDER BY TRY_CAST(o.[DataStato] AS DATETIME) DESC
                ) AS rn
            FROM dbo.tbOrdini o
            INNER JOIN dbo.tbOfferte f
                ON o.[idOfferta] = f.[IDOfferta]
            INNER JOIN dbo.tbDealers d
                ON o.[idDealer] = d.[idDealer]
            WHERE o.[Stato] = 1
              AND f.[IDOperatore] = 13
              AND d.[AGENTE] = @agente
        )
        SELECT TOP 5
            FORMAT(TRY_CAST(o.[DataStato] AS DATETIME), 'dd.MM.yyyy') AS Data,
            o.[Titolo] AS Valore,
            d.[RagioneSociale],
            o.[Segmento],
            o.[Tipo] AS [Tipo Ordine]
        FROM OrdiniUnici o
        INNER JOIN dbo.tbDealers d
            ON o.[idDealer] = d.[idDealer]
        WHERE o.rn = 1
        ORDER BY TRY_CAST(o.[DataStato] AS DATETIME) DESC
      `;
      request = request.input('agente', sql.NVarChar, agenteNome);
    } else {
      return res.status(400).json({ error: 'Operatore non supportato (implementare le query specifiche)' });
    }

    const result = await request.query(attivazioniQuery);
    // Mappatura chiavi esattamente come la query
    const mapped = (result.recordset || []).map(row => ({
      Data: row.Data,
      Valore: row.Valore,
      RagioneSociale: row.RagioneSociale,
      Segmento: row.Segmento,
      TipoOrdine: row['Tipo Ordine']
    }));
    return res.json(mapped);
  } catch (err) {
    console.error('Errore in /api/ultime-attivazioni-agente:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});

app.get('/api/reportistica-agente', authenticateToken, async (req, res) => {
  try {
    const agenteNome = req.user.agenteNome || req.user.nome || req.user.name || req.user.email || req.user.userId;
    if (!agenteNome) {
      return res.status(400).json({ error: 'Nome agente non trovato nel token' });
    }
    const type = (req.query.type || '').toLowerCase();
    if (!['fastweb','energia','sky','weedoo','altri'].includes(type)) {
      return res.status(400).json({ error: 'Tipo report non valido' });
    }
    await sql.connect(dbConfig);
    let result;
    if (type === 'fastweb') {
      result = await sql.query(`EXEC dbo.GetOrderStatisticsByAgent2025 @agente = N'${agenteNome}'`);
    } else if (type === 'energia') {
      result = await sql.query(`EXEC REPORT_ENERGIA_AGENTE_STATION @CodiceAgenteLarge = N'${agenteNome}'`);
    } else if (type === 'sky') {
      result = await sql.query(`EXEC sp_GetDealerOffersSummaryByAgent2025 @agente = N'${agenteNome}'`);
    } else if (type === 'weedoo') {
      result = await sql.query(`
        SELECT
          d.AGENTE AS Agente,
          FORMAT(o.DataOra, 'yyyy/MM') AS AnnoMese,
          d.RagioneSociale AS Point,
          SUM(CASE WHEN o.idofferta = 341 THEN 1 ELSE 0 END) AS LUCE,
          SUM(CASE WHEN o.idofferta = 342 THEN 1 ELSE 0 END) AS GAS,
          COUNT(*) AS Totale,
          CAST(GETDATE() AS date) AS DataAggiornamento
        FROM dbo.tbOrdini o
        INNER JOIN dbo.tbDealers d ON o.utente = d.RecapitoEmail
        WHERE o.idofferta IN (341, 342)
          AND o.stato = 1
          AND d.AGENTE = N'${agenteNome}'
        GROUP BY d.AGENTE, FORMAT(o.DataOra, 'yyyy/MM'), d.RagioneSociale
        ORDER BY AnnoMese, d.AGENTE, d.RagioneSociale
      `);
    } else if (type === 'altri') {
      result = await sql.query(`
        WITH MonthlyData AS (
          SELECT
            FORMAT(ord.DataStato, 'yyyy/MM') AS [ANNO/MESE],
            d.RagioneSociale AS Point,
            SUM(CASE WHEN o.IDOPERATORE = 5 THEN 1 ELSE 0 END) AS ILIAD,
            SUM(CASE WHEN o.IDOPERATORE = 6 THEN 1 ELSE 0 END) AS KENA,
            SUM(CASE WHEN o.IDOPERATORE = 7 THEN 1 ELSE 0 END) AS [1MOBILE],
            SUM(CASE WHEN o.IDOPERATORE = 13 THEN 1 ELSE 0 END) AS WEEDOO
          FROM dbo.tbOFFERTE o
          JOIN dbo.tbordini ord ON o.IDOFFERTA = ord.IDOFFERTA
          JOIN dbo.tbDealers d ON ord.iddealer = d.idDealer
          WHERE o.IDOPERATORE IN (4, 5, 6, 7, 13)
            AND d.agente = N'${agenteNome}'
            AND ord.Stato = '1'
          GROUP BY FORMAT(ord.DataStato, 'yyyy/MM'), d.RagioneSociale
        ),
        MonthlyTotals AS (
          SELECT
            FORMAT(ord.DataStato, 'yyyy/MM') AS [ANNO/MESE],
            UPPER(CONCAT('Totale ', FORMAT(ord.DataStato, 'MMMM', 'it-IT'))) AS Point,
            SUM(CASE WHEN o.IDOPERATORE = 5 THEN 1 ELSE 0 END) AS ILIAD,
            SUM(CASE WHEN o.IDOPERATORE = 6 THEN 1 ELSE 0 END) AS KENA,
            SUM(CASE WHEN o.IDOPERATORE = 7 THEN 1 ELSE 0 END) AS [1MOBILE],
            SUM(CASE WHEN o.IDOPERATORE = 13 THEN 1 ELSE 0 END) AS WEEDOO
          FROM dbo.tbOFFERTE o
          JOIN dbo.tbordini ord ON o.IDOFFERTA = ord.IDOFFERTA
          JOIN dbo.tbDealers d ON ord.iddealer = d.idDealer
          WHERE o.IDOPERATORE IN (4, 5, 6, 7, 13)
            AND d.agente = N'${agenteNome}'
            AND ord.Stato = '1'
          GROUP BY FORMAT(ord.DataStato, 'yyyy/MM'), FORMAT(ord.DataStato, 'MMMM', 'it-IT')
        )
        SELECT [ANNO/MESE], Point, ILIAD, KENA, [1MOBILE], WEEDOO
        FROM (
          SELECT [ANNO/MESE], Point, ILIAD, KENA, [1MOBILE], WEEDOO, 0 AS SortOrder FROM MonthlyTotals
          UNION ALL
          SELECT [ANNO/MESE], Point, ILIAD, KENA, [1MOBILE], WEEDOO, 1 AS SortOrder FROM MonthlyData
        ) AS CombinedData
        ORDER BY [ANNO/MESE] DESC, SortOrder, CASE WHEN Point LIKE 'Totale%' THEN 0 ELSE 1 END, Point
      `);
    } else {
      return res.status(400).json({ error: 'Tipo report non gestito' });
    }
    return res.json(result.recordset);
  } catch (err) {
    console.error('/api/reportistica-agente error:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});

// --- API: DOCUMENTAZIONE ---
// GET /api/documentazione
app.get('/api/documentazione', authenticateToken, async (req, res) => {
  try {
    await sql.connect(dbConfig);
    const query = 'SELECT IDFile, Operatore, Titolo, Link FROM dbo.tbFiles ORDER BY Operatore, Titolo';
    const result = await sql.query(query);
    res.json(result.recordset);
  } catch (err) {
    console.error('/api/documentazione error:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});

// --- ECOMMERCE: API PRODOTTI ---
// GET /api/prodotti?segmento=SIM&idOperatore=11
app.get('/api/prodotti', authenticateToken, async (req, res) => {
  try {
    // L'autenticazione JWT è già gestita dal middleware authenticateToken
    const { segmento, idOperatore } = req.query;
    if (!segmento || !idOperatore) {
      return res.status(400).json({ error: 'Parametro segmento e idOperatore obbligatori' });
    }

    // Mappa FIN -> CELL per la ricerca DB
    let segmentoDb = segmento;
    if (segmento === 'FIN') segmentoDb = 'CELL';

    await sql.connect(dbConfig);
    const request = new sql.Request();
    request.input('segmento', sql.NVarChar, segmentoDb);
    request.input('idOperatore', sql.Int, parseInt(idOperatore, 10));

    const query = `
      SELECT
        IDOfferta AS id,
        Titolo AS nome,
        DescrizioneBreve AS descrizione,
        Crediti AS prezzo,
        LogoLink,
        Segmento AS segmento,
        idOperatore,
        LimiteSIM AS disponibilita,
        Tipo AS categoria,
        ISNULL(SpeseSpedizione, 0) AS SpeseSpedizione
      FROM dbo.tbOfferte
      WHERE tipoOfferta = 4
        AND Segmento = @segmento
        AND idOperatore = @idOperatore
        AND (OnlyFor IS NULL OR OnlyFor = '')
        AND ISNULL(Offerta_Inviata, 1) = 1
        AND ISNULL([ValidaDal], GETDATE()) <= GETDATE()
        AND ISNULL([ValidaAl], GETDATE()) >= GETDATE()
    `;
    const result = await request.query(query);
    res.json({ attivazioni: result.recordset });
  } catch (err) {
    console.error('/api/prodotti error:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});

// --- API: TEMPLATE DINAMICO OFFERTA ---
// GET /api/template-offerta/:idOfferta
app.get('/api/template-offerta/:idOfferta', authenticateToken, async (req, res) => {
  try {
    // Autenticazione JWT
    const authHeader = req.headers['authorization'];
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token mancante' });
    }
    const token = authHeader.substring(7);
    try {
      jwt.verify(token, 'TUO_JWT_SECRET');
    } catch (err) {
      return res.status(401).json({ error: 'Token non valido' });
    }
    const idOfferta = req.params.idOfferta;
    if (!idOfferta) return res.status(400).json({ error: 'idOfferta obbligatorio' });
    await sql.connect(dbConfig);
    const request = new sql.Request();
    request.input('id', sql.Int, parseInt(idOfferta, 10));
    const query = 'SELECT TemplateDatiOfferta FROM dbo.tbOfferte WHERE IDOfferta = @id';
    const result = await request.query(query);
    if (!result.recordset.length || !result.recordset[0].TemplateDatiOfferta) {
      return res.status(404).json({ error: 'Nome template non trovato per questa offerta' });
    }
    const nomeTemplate = result.recordset[0].TemplateDatiOfferta;
    const fs = require('fs');
    let templatesData;
    try {
      templatesData = fs.readFileSync(__dirname + '/templates.json', 'utf-8');
    } catch (err) {
      return res.status(500).json({ error: 'Impossibile leggere templates.json', details: err.message });
    }
    let templatesArr;
    try {
      templatesArr = JSON.parse(templatesData);
    } catch (err) {
      return res.status(500).json({ error: 'templates.json non valido', details: err.message });
    }
    const template = templatesArr.find(t => t.template === nomeTemplate);
    if (!template) {
      return res.status(404).json({ error: 'Template non trovato in templates.json' });
    }
    res.json(template);
  } catch (err) {
    console.error('/api/template-offerta error:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});

// Endpoint chat semplice per bot
app.post('/webchat', express.json(), async (req, res) => {
  const { text, user_id } = req.body;
  // Qui puoi collegare la tua logica bot, per ora rispondiamo con un echo
  let reply = `Hai scritto: ${text}`;
  // Esempio: if(text.match(/ciao/i)) reply = 'Ciao! Come posso aiutarti?';
  res.json({ reply });
});

// Endpoint per salvare la cronologia chat
app.post('/webchat/history', express.json(), async (req, res) => {
  const { user_id, history } = req.body;
  if (!user_id || !Array.isArray(history)) return res.status(400).json({ error: 'Dati mancanti' });
  try {
    await sql.connect(dbConfig);
    // Upsert: aggiorna se esiste, altrimenti inserisci
    const check = await sql.query`SELECT COUNT(*) as cnt FROM tbChatHistory WHERE UserId = ${user_id}`;
    if (check.recordset[0].cnt > 0) {
      await sql.query`UPDATE tbChatHistory SET History = ${JSON.stringify(history)} WHERE UserId = ${user_id}`;
    } else {
      await sql.query`INSERT INTO tbChatHistory (UserId, History) VALUES (${user_id}, ${JSON.stringify(history)})`;
    }
    res.json({ ok: true });
  } catch (e) {
    res.status(500).json({ error: 'Errore salvataggio cronologia', details: e.message });
  }
});

// Endpoint per recuperare la cronologia chat
app.get('/webchat/history', async (req, res) => {
  const user_id = req.query.user_id;
  if (!user_id) return res.status(400).json({ error: 'user_id mancante' });
  try {
    await sql.connect(dbConfig);
    const result = await sql.query`SELECT TOP 1 History FROM tbChatHistory WHERE UserId = ${user_id}`;
    if (result.recordset.length) {
      res.json({ history: JSON.parse(result.recordset[0].History) });
    } else {
      res.json({ history: [] });
    }
  } catch (e) {
    res.status(500).json({ error: 'Errore recupero cronologia', details: e.message });
  }
});

// Endpoint proxy per gestire le richieste CORS
app.post('/api/proxy/chat', express.json(), async (req, res) => {
  try {
    // Estrai il token JWT dall'header Authorization
    const authHeader = req.headers['authorization'];
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token mancante' });
    }
    
    // Dati utente già disponibili grazie al middleware authenticateToken
    const userId = req.user.phoneNumber || 'web_user';
    const { text } = req.body; 
    
    if (!text) {
      return res.status(400).json({ error: 'Testo del messaggio mancante' });
    }
    
    console.log(`Inoltro messaggio al bot da ${userId}:`, text);
    
    const response = await axios.post('https://bot.kimweb.agency/from-site', {
      text,
      user_id: userId
    });
    
    res.json(response.data);
  } catch (error) {
    console.error('Errore nella comunicazione con il bot:', error.message);
    res.status(500).json({
      reply: 'Al momento non riesco a contattare il servizio di assistenza. Riprova tra qualche minuto.'
    });
  }
});

app.get('/api/credito-plafond', authenticateToken, async (req, res) => {
  console.log('--- /api/credito-plafond chiamato ---');
  try {
    const idDealer = req.user.dealerId;
    if (!idDealer) {
      console.error('ID dealer non trovato nel token JWT (req.user)');
      return res.status(401).json({ error: 'ID dealer non valido nel token' });
    }
    console.log('IDDealer da req.user:', idDealer);
    
    try {
      // La connessione al database è gestita dal middleware globale
      const request = new sql.Request();
      // Query per il credito
      request.input('idDealer', sql.Int, idDealer);
      const creditoQuery = `
        SELECT ISNULL(SUM(t.crediti), 0) AS credito
        FROM dbo.tbtransazioni t
        JOIN dbo.tbdealers d ON t.iddealer = d.iddealer
        WHERE d.iddealer = @idDealer
      `;
      
      console.log('Eseguo creditoQuery:', creditoQuery, 'con idDealer:', idDealer);
      const creditoRes = await request.query(creditoQuery);
      console.log('Risultato creditoRes:', JSON.stringify(creditoRes.recordset, null, 2));
      
      const credito = creditoRes.recordset[0].credito || 0;
      console.log('Credito calcolato:', credito);
      // Restituisci il credito in euro (già in euro in tabella)
      res.json({ credito });
    } catch (err) {
      console.error('ERRORE /api/credito-plafond:', err.message, err.stack, err);
      res.status(500).json({ error: 'Errore server', details: err.message, stack: err.stack });
    }
  } catch (err) {
    console.error('ERRORE GRAVE /api/credito-plafond:', err.message, err.stack, err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});

// Endpoint per ottenere gli operatori principali (con SKY raggruppato)
app.get('/api/operatori', authenticateToken, async (req, res) => {
  try {
    await sql.connect(dbConfig);
    
    // Ottieni tutti gli operatori tranne quelli esclusi
    const result = await sql.query`
      SELECT IDOperatore as id, Denominazione as nome, 
             CASE WHEN IDOperatore IN (3, 8, 12, 14) THEN 1 ELSE 0 END as isSky
      FROM dbo.tbOperatori2 
      WHERE IDOperatore NOT IN (4, 10, 11)  -- Escludi RABONA, ASSISTENZA, PRODOTTI
      ORDER BY isSky DESC, Denominazione`;
    
    // Raggruppa gli operatori SKY in un unico oggetto
    const operatori = [];
    const skyOperators = [];
    
    result.recordset.forEach(op => {
      if (op.isSky) {
        skyOperators.push({
          id: op.id,
          nome: op.nome
        });
      } else {
        operatori.push({
          id: op.id,
          nome: op.nome
        });
      }
    });
    
    // Aggiungi l'opzione SKY all'inizio
    if (skyOperators.length > 0) {
      operatori.unshift({
        id: 'SKY',
        nome: 'SKY',
        isSkyGroup: true
      });
    }
    
    res.json(operatori);
  } catch (err) {
    console.error('Errore in /api/operatori:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});

// Endpoint per ottenere i sottotipi SKY
app.get('/api/sky-tipi', async (req, res) => {
  // TODO: implementare endpoint reale se necessario
  res.json([]);
});

// Endpoint per ottenere le tipologie disponibili per un operatore
app.get('/api/tipologie', authenticateToken, async (req, res) => {
  try {
    const { operatore } = req.query;
    if (!operatore) {
      return res.status(400).json({ error: 'Parametro operatore obbligatorio' });
    }
    await sql.connect(dbConfig);

    // Ricava tutte le tipologie disponibili per quell’operatore dalle offerte attive
    let result;
    if (parseInt(operatore) === 6) {
      // KENA MOBILE: nessun filtro aggiuntivo
      result = await sql.query`
        SELECT DISTINCT
          CASE
            WHEN o.Segmento = 'RES' THEN 'RESIDENZIALE'
            WHEN o.Segmento = 'SHP' THEN 'BUSINESS'
            ELSE o.Segmento
          END AS tipologia
        FROM dbo.tbOfferte o
        WHERE o.idOperatore = 6
      `;
    } else {
      result = await sql.query`
        SELECT DISTINCT
          CASE
            WHEN o.Segmento = 'RES' THEN 'RESIDENZIALE'
            WHEN o.Segmento = 'SHP' THEN 'BUSINESS'
            ELSE o.Segmento
          END AS tipologia
        FROM dbo.tbOfferte o
        WHERE o.idOperatore = ${parseInt(operatore)}
          AND o.Segmento != 'FIN'
          AND (o.OnlyFor IS NULL OR o.OnlyFor = '')
          AND ISNULL(o.Offerta_Inviata, 1) = 1
          AND ISNULL(o.ValidaDal, GETDATE()) <= GETDATE()
          AND ISNULL(o.ValidaAl, GETDATE()) >= GETDATE()
      `;
    }
    const tipologie = result.recordset.map(r => r.tipologia);
    res.json(tipologie);
  } catch (err) {
    console.error('Errore in /api/tipologie:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});
// Endpoint per ottenere le offerte filtrate per operatore e tipologia
app.get('/api/offerte', authenticateToken, async (req, res) => {
  try {
    const { operatore, tipologia, segmento } = req.query;
    
    // Se c'è il parametro segmento, usa la logica per i prodotti
    if (segmento) {
      return await getProdottiBySegmento(req, res, segmento);
    }
    
    // Altrimenti usa la logica originale per le offerte
    if (!operatore) {
      return res.status(400).json({ error: 'Parametro operatore obbligatorio' });
    }

    await sql.connect(dbConfig);
    let query = '';
    const operatorId = parseInt(operatore);
    if (req.query.from === 'attivazioni') {
      if ([3, 8, 12, 14].includes(operatorId) && tipologia) {
        // SKY su attivazioni
        query = `
          SELECT  
            o.IDOfferta,
            op.Denominazione AS NomeOperatore,
            o.LogoLink,
            o.Titolo,
            o.DescrizioneBreve,
            o.Crediti,
            o.idOperatore,
            o.Segmento,
            o.LogoLink AS LogoOperatore,
            o.TemplateDatiOfferta,
            o.LimiteSIM AS disponibilita,
            o.Tipo AS categoria
          FROM dbo.tbOfferte o
          INNER JOIN dbo.tbOperatori2 op ON o.idOperatore = op.IDOperatore
          WHERE o.idOperatore = ${operatorId}
            AND o.Segmento = '${tipologia}'
            AND ISNULL(o.ValidaDal, GETDATE()) <= GETDATE()
            AND ISNULL(o.ValidaAl, GETDATE()) >= GETDATE()
            AND op.IDOperatore IS NOT NULL
          ORDER BY o.Crediti ASC`;
      } else {
        // ATTIVAZIONI per altri operatori: mostra solo offerte con Segmento RES o BUS
        query = `
          SELECT  
            o.IDOfferta,
            op.Denominazione AS NomeOperatore,
            o.LogoLink,
            o.Titolo,
            o.DescrizioneBreve,
            o.Crediti,
            o.idOperatore,
            o.Segmento,
            o.LogoLink AS LogoOperatore,
            o.TemplateDatiOfferta,
            o.LimiteSIM AS disponibilita,
            o.Tipo AS categoria
          FROM dbo.tbOfferte o
          INNER JOIN dbo.tbOperatori2 op ON o.idOperatore = op.IDOperatore
          WHERE o.idOperatore = ${operatorId}
            AND (o.Segmento = 'RES' OR o.Segmento = 'BUS')
            AND ISNULL(o.ValidaDal, GETDATE()) <= GETDATE()
            AND ISNULL(o.ValidaAl, GETDATE()) >= GETDATE()
            AND op.IDOperatore IS NOT NULL
          ORDER BY o.Crediti ASC`;
      }
    } else {
      // Pagina assistenza: solo offerte SOS
      query = `
        SELECT  
          o.IDOfferta,
          op.Denominazione AS NomeOperatore,
          o.LogoLink,
          o.Titolo,
          o.DescrizioneBreve,
          o.Crediti,
          o.idOperatore,
          o.Segmento,
          o.LogoLink AS LogoOperatore,
          o.TemplateDatiOfferta,
          o.LimiteSIM AS disponibilita,
          o.Tipo AS categoria
        FROM dbo.tbOfferte o
        INNER JOIN dbo.tbOperatori2 op ON o.idOperatore = op.IDOperatore
        WHERE o.idOperatore = ${operatorId}
          AND o.Tipo = 'SOS'
          AND ISNULL(o.ValidaDal, GETDATE()) <= GETDATE()
          AND ISNULL(o.ValidaAl, GETDATE()) >= GETDATE()
          AND op.IDOperatore IS NOT NULL
        ORDER BY o.Crediti ASC`;
    }
    console.log('Esecuzione query offerte:', query);
    const result = await sql.query(query);
    res.json(result.recordset);
  } catch (err) {
    console.error('Errore in /api/offerte:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  }
});

// Funzione per ottenere i prodotti filtrati per segmento (SIM o TELEFONI)
async function getProdottiBySegmento(req, res, segmento) {
  try {
    await sql.connect(dbConfig);
    
    // Mappa i segmenti richiesti ai valori nel database
    let query = '';
    let params = {};
    
    if (segmento === 'SIM') {
      query = `
        SELECT
          o.IDOfferta AS id,
          o.Titolo AS nome,
          o.DescrizioneBreve AS descrizione,
          o.Crediti AS prezzo,
          o.LogoLink,
          o.Segmento,
          o.idOperatore,
          o.LimiteSIM AS disponibilita,
          o.Tipo AS categoria,
          op.Denominazione AS NomeOperatore
        FROM dbo.tbOfferte o
        INNER JOIN dbo.tbOperatori2 op ON o.idOperatore = op.IDOperatore
        WHERE o.tipoOfferta = 4
          AND o.Segmento = 'SIM'
          AND (o.OnlyFor IS NULL OR o.OnlyFor = '')
          AND ISNULL(o.Offerta_Inviata, 1) = 1
          AND ISNULL(o.ValidaDal, GETDATE()) <= GETDATE()
          AND ISNULL(o.ValidaAl, GETDATE()) >= GETDATE()
        ORDER BY o.Titolo`;
    } else if (segmento === 'FIN') { // TELEFONI
      query = `
        SELECT
          o.IDOfferta AS id,
          o.Titolo AS nome,
          o.DescrizioneBreve AS descrizione,
          o.Crediti AS prezzo,
          o.LogoLink,
          o.Segmento,
          o.idOperatore,
          o.LimiteSIM AS disponibilita,
          o.Tipo AS categoria,
          op.Denominazione AS NomeOperatore
        FROM dbo.tbOfferte o
        INNER JOIN dbo.tbOperatori2 op ON o.idOperatore = op.IDOperatore
        WHERE o.tipoOfferta = 4
          AND o.Segmento = 'CELL'
          AND o.idOperatore = 11
          AND (o.OnlyFor IS NULL OR o.OnlyFor = '')
          AND ISNULL(o.Offerta_Inviata, 1) = 1
          AND ISNULL(o.ValidaDal, GETDATE()) <= GETDATE()
          AND ISNULL(o.ValidaAl, GETDATE()) >= GETDATE()
        ORDER BY o.Titolo`;
    } else {
      return res.status(400).json({ error: 'Segmento non valido' });
    }

    console.log('Esecuzione query prodotti per segmento:', segmento);
    const result = await sql.query(query);
    
    res.json(result.recordset);
  } catch (err) {
    console.error('Errore nel recupero prodotti per segmento:', err);
    res.status(500).json({ error: 'Errore server', details: err.message });
  } finally {
  }
}

app.get('/api/andamento', authenticateToken, async (req, res) => {
  try {
    console.log('Richiesta ricevuta su /api/andamento');
    

    // La connessione al database è gestita dal middleware globale
    const result = await sql.query`
      WITH MonthlyData AS (
        SELECT 
          FORMAT(ord.DataStato, 'yyyy/MM') AS [ANNO_MESE],
          d.RagioneSociale AS Point,
          SUM(CASE WHEN o.IDOPERATORE = 5 THEN 1 ELSE 0 END) AS ILIAD,
          SUM(CASE WHEN o.IDOPERATORE = 6 THEN 1 ELSE 0 END) AS KENA,
          SUM(CASE WHEN o.IDOPERATORE = 7 THEN 1 ELSE 0 END) AS [1MOBILE],
          SUM(CASE WHEN o.IDOPERATORE = 13 THEN 1 ELSE 0 END) AS WEEDOO
        FROM 
          dbo.tbOFFERTE o
          JOIN dbo.tbordini ord ON o.IDOFFERTA = ord.IDOFFERTA
          JOIN dbo.tbDealers d ON ord.iddealer = d.idDealer
        WHERE 
          o.IDOPERATORE IN (4, 5, 6, 7, 13)
          AND d.idDealer = ${req.user.dealerId}
          AND ord.Stato = '1'
        GROUP BY 
          FORMAT(ord.DataStato, 'yyyy/MM'), d.RagioneSociale
      ),
      MonthlyTotals AS (
        SELECT 
          FORMAT(ord.DataStato, 'yyyy/MM') AS [ANNO_MESE],
          'TOTALE ' + UPPER(FORMAT(ord.DataStato, 'MMMM', 'it-IT')) AS Point,
          SUM(CASE WHEN o.IDOPERATORE = 5 THEN 1 ELSE 0 END) AS ILIAD,
          SUM(CASE WHEN o.IDOPERATORE = 6 THEN 1 ELSE 0 END) AS KENA,
          SUM(CASE WHEN o.IDOPERATORE = 7 THEN 1 ELSE 0 END) AS [1MOBILE],
          SUM(CASE WHEN o.IDOPERATORE = 13 THEN 1 ELSE 0 END) AS WEEDOO
        FROM 
          dbo.tbOFFERTE o
          JOIN dbo.tbordini ord ON o.IDOFFERTA = ord.IDOFFERTA
          JOIN dbo.tbDealers d ON ord.iddealer = d.idDealer
        WHERE 
          o.IDOPERATORE IN (4, 5, 6, 7, 13)
          AND d.idDealer = ${req.user.dealerId}
        GROUP BY 
          FORMAT(ord.DataStato, 'yyyy/MM'), FORMAT(ord.DataStato, 'MMMM', 'it-IT')
      )
      SELECT 
        [ANNO_MESE] AS ANNO_MESE,
        Point,
        ISNULL(ILIAD, 0) AS ILIAD,
        ISNULL(KENA, 0) AS KENA,
        ISNULL([1MOBILE], 0) AS [1MOBILE],
        ISNULL(WEEDOO, 0) AS WEEDOO
      FROM (
        SELECT 
          [ANNO_MESE],
          Point,
          ILIAD,
          KENA,
          [1MOBILE],
          WEEDOO,
          0 AS SortOrder
        FROM MonthlyTotals
      
        UNION ALL
      
        SELECT 
          [ANNO_MESE],
          Point,
          ILIAD,
          KENA,
          [1MOBILE],
          WEEDOO,
          1 AS SortOrder
        FROM MonthlyData
      ) AS CombinedData
      ORDER BY 
        [ANNO_MESE] DESC,
        SortOrder,
        CASE WHEN Point LIKE 'TOTALE%' THEN 0 ELSE 1 END,
        Point`;

    res.json(result.recordset);
  } catch (err) {
    console.error('Errore nel recupero dei dati di andamento:', err);
    res.status(500).json({ error: 'Errore nel recupero dei dati di andamento', details: err.message });
  }
});

// --- API: OBIETTIVI ---
// GET /api/obiettivi
app.get('/api/obiettivi', authenticateToken, async (req, res) => {
  let fastwebStats = {}; // Spostato qui per renderlo disponibile in tutto lo scope
  
  try {
    // 1️⃣ Auth e validazione
    const authHeader = req.headers['authorization'];
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token mancante' });
    }

    const token = authHeader.split(' ')[1];
    // Dati utente già disponibili grazie al middleware authenticateToken
    const idDealer = parseInt(req.user.dealerId, 10);
    if (isNaN(idDealer)) {
      return res.status(401).json({ error: 'ID dealer non valido' });
    }

    // 2️⃣ Anno / Mese attuale
    const now = new Date();
    const anno = now.getFullYear();
    const mese = now.getMonth() + 1;

    // 3️⃣ Connessione al database
    await sql.connect(dbConfig);
    
    // 3️⃣ Leggi tutte le soglie_report
    const request = new sql.Request();
    request.input('anno', sql.Int, anno);
    request.input('mese', sql.Int, mese);

    const soglieRes = await request.query(`
      SELECT operatore, categoria, segmento, 
             soglia_1_min, soglia_1_max, 
             soglia_2_min, soglia_2_max, 
             soglia_3_min, soglia_3_max, 
             soglia_4_min, soglia_4_max 
      FROM soglie_report 
      WHERE anno = @anno AND mese = @mese`);

    const soglie = soglieRes.recordset;

    // 5️⃣ Funzione helper per calcolare il target e i mancanti
    const calcolaMancano = (attuale, sogliaRow) => {
      const soglieOrdered = [
        sogliaRow.soglia_1_max,
        sogliaRow.soglia_2_max,
        sogliaRow.soglia_3_max,
        sogliaRow.soglia_4_max
      ].filter(s => s != null);
      
      for (const sogliaMax of soglieOrdered) {
        if (attuale < sogliaMax) {
          return Math.max(0, sogliaMax - attuale);
        }
      }
      return 0;
    };

    const getTarget = (attuale, sogliaRow) => {
      const soglieOrdered = [
        sogliaRow.soglia_1_max,
        sogliaRow.soglia_2_max,
        sogliaRow.soglia_3_max,
        sogliaRow.soglia_4_max
      ].filter(x => x != null);
      
      for (const sogliaMax of soglieOrdered) {
        if (attuale < sogliaMax) {
          return sogliaMax;
        }
      }
      return soglieOrdered[soglieOrdered.length - 1] || 0;
    };

    // 6️⃣ Carichiamo i dati per ogni operatore
    
    // 1. Fastweb TLC
    try {
      console.log('Esecuzione query GetOrderStatisticsByDealerByidDealer per idDealer:', idDealer);
      const fastwebStatsRes = await sql.query`EXEC GetOrderStatisticsByDealerByidDealer @idDealer = ${idDealer}`;
      fastwebStats = fastwebStatsRes.recordset[0] || {};
      console.log('Risultati Fastweb TLC:', JSON.stringify(fastwebStats, null, 2));
      
      // Log delle soglie trovate per Fastweb TLC
      const soglieFastweb = soglie.filter(s => s.operatore === 'Fastweb' && s.categoria !== 'ENERGIA');
      console.log('Soglie trovate per Fastweb TLC:', JSON.stringify(soglieFastweb, null, 2));
    } catch (error) {
      console.error('Errore durante l\'esecuzione di GetOrderStatisticsByDealerByidDealer:', error);
      fastwebStats = {};
    }

    const mappaCategorieFastweb = {
      'MOBILE RES': fastwebStats['MOBILI RES'] || 0,
      'MOBILE SHP': fastwebStats['MOBILI BUS'] || 0,
      'FISSO RES': fastwebStats['FISSI RES'] || 0,
      'FISSO SHP': fastwebStats['FISSI BUS'] || 0,
      'Convergenza RES': fastwebStats['di cui CONV_RES'] || 0,
      'Convergenza SHP': fastwebStats['di cui CONV_BUS'] || 0
    };

    const categorieFastweb = soglie
      .filter(s => s.operatore === 'Fastweb' && s.categoria !== 'ENERGIA')
      .map(s => {
        const nomeCategoria = `${s.categoria} ${s.segmento}`.trim();
        const attuale = mappaCategorieFastweb[nomeCategoria] || 0;
        const target = getTarget(attuale, s);
        const mancano = calcolaMancano(attuale, s);

        return { nome: nomeCategoria, attuale, target, mancano };
      });

    // 2. Fastweb ENERGIA
    const energiaRes = await sql.query`
      EXEC ReportContrattiEnergiaPeridDealer @idDealer = ${idDealer}`;
    const energiaStats = energiaRes.recordset[0] || {};

    const energiaAttualeRES = energiaStats['Segmento RES'] || 0;
    const energiaAttualeSHP = energiaStats['Segmento BUS'] || 0;

    const categorieEnergia = [];

    const sogliaEnergiaRES = soglie.find(s => s.operatore === 'Fastweb' && s.categoria === 'ENERGIA' && s.segmento === 'RES');
    if (sogliaEnergiaRES) {
      categorieEnergia.push({
        nome: 'Energia RES',
        attuale: energiaAttualeRES,
        target: getTarget(energiaAttualeRES, sogliaEnergiaRES),
        mancano: calcolaMancano(energiaAttualeRES, sogliaEnergiaRES)
      });
    }

    const sogliaEnergiaSHP = soglie.find(s => s.operatore === 'Fastweb' && s.categoria === 'ENERGIA' && s.segmento === 'SHP');
    if (sogliaEnergiaSHP) {
      categorieEnergia.push({
        nome: 'Energia SHP',
        attuale: energiaAttualeSHP,
        target: getTarget(energiaAttualeSHP, sogliaEnergiaSHP),
        mancano: calcolaMancano(energiaAttualeSHP, sogliaEnergiaSHP)
      });
    }

    // 3. Sky Mobile & WIFI
    const skyMobileWifiRes = await sql.query`
      EXEC ReportAttivazioniSkyMobileWifibyIddealer @idDealer = ${idDealer}`;
    const skyMobileWifiStats = skyMobileWifiRes.recordset[0] || {};
    
    // Debug: Log the structure of the returned data
    console.log('Sky Mobile & WIFI Stats Raw:', JSON.stringify(skyMobileWifiStats, null, 2));

    // Mappa per le categorie Sky Mobile & WIFI
    const mappaSkyMobileWifi = {
      'Mobile': skyMobileWifiStats.Mobile || 0,
      'WIFI': skyMobileWifiStats.WIFI || 0,
      'Mobile + WIFI': skyMobileWifiStats['Mobile + WIFI'] || 0
    };

    const categorieSkyMobileWifi = Object.keys(mappaSkyMobileWifi).map(cat => {
      const attuale = mappaSkyMobileWifi[cat];
      const sogliaRow = soglie.find(s => s.operatore === 'Sky Mobile & WIFI' && s.categoria === cat);
      const target = sogliaRow ? getTarget(attuale, sogliaRow) : 0;
      const mancano = sogliaRow ? calcolaMancano(attuale, sogliaRow) : 0;

      return { nome: cat, attuale, target, mancano };
    });

    // 4. Sky TV
    const skyTvRes = await sql.query`
      EXEC ReportAttivazioniSkyTV @idDealer = ${idDealer}`;
    const skyTvStats = skyTvRes.recordset[0] || {};

    const mappaSkyTv = {
      'ONLY TV': skyTvStats['ONLY TV'] || 0,
      '3P': skyTvStats['3P'] || 0,
      'GLASS': skyTvStats['GLASS'] || 0,
      '3P GLASS': skyTvStats['3P GLASS'] || 0
    };

    const categorieSkyTv = Object.keys(mappaSkyTv).map(cat => {
      const attuale = mappaSkyTv[cat];
      const sogliaRow = soglie.find(s => s.operatore === 'Sky TV' && s.categoria === cat);
      const target = sogliaRow ? getTarget(attuale, sogliaRow) : 0;
      const mancano = sogliaRow ? calcolaMancano(attuale, sogliaRow) : 0;

      return { nome: cat, attuale, target, mancano };
    });

    // 7️⃣ Prepara la risposta finale
    const risposta = {
      obiettivi: [
        { operatore: 'Fastweb TLC', categorie: categorieFastweb },
        { operatore: 'Fastweb ENERGIA', categorie: categorieEnergia },
        { operatore: 'Sky Mobile & WIFI', categorie: categorieSkyMobileWifi },
        { operatore: 'Sky TV', categorie: categorieSkyTv }
      ]
    };


    res.json(risposta);
  } catch (err) {
    console.error('Errore in /api/obiettivi:', err);
    res.status(500).json({ error: 'Errore nel recupero degli obiettivi', details: err.message });
  }
});